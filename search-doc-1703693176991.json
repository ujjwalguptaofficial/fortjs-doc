{"searchDocs":[{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"nestjs  framework  typescript  javascript  MVC","version":null},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"nestjs  framework  typescript  javascript  MVC","version":null},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"nestjs  framework  typescript  javascript  MVC","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"nestjs  framework  typescript  javascript  MVC","version":null},{"title":"Components","type":0,"sectionRef":"#","url":"/docs/advanced/components","content":"","keywords":"components executeMethod fortjs node","version":"Next"},{"title":"controller​","type":1,"pageTitle":"Components","url":"/docs/advanced/components#controller","content":"As name sounds - it has access to Controller and expose following methods - getInstancegetMethodexecuteMethod ","version":"Next","tagName":"h2"},{"title":"getInstance​","type":1,"pageTitle":"Components","url":"/docs/advanced/components#getinstance","content":"getInstance allows you to get the instance or object of a Controller by its name. import { Components } from &quot;fortjs&quot;; const instance = Components.controller.getInstance(&quot;DefaultController&quot;)  You can also initialize controller by passing initialization data - import { Components } from &quot;fortjs&quot;; const instance = Components.controller.getInstance(&quot;DefaultController&quot;,{ query:{ name:'Ujjwal Gupta' } })  For all the initialization property, please read Initialize doc ","version":"Next","tagName":"h3"},{"title":"getMethod​","type":1,"pageTitle":"Components","url":"/docs/advanced/components#getmethod","content":"getMethod can be used to get a method of a controller.  import { Components } from &quot;fortjs&quot;; const method = Components.controller.getMethod(&quot;UserController&quot;, &quot;createUser&quot;);  ","version":"Next","tagName":"h3"},{"title":"executeMethod​","type":1,"pageTitle":"Components","url":"/docs/advanced/components#executemethod","content":"executeMethod can be used to execute a method of a controller. It also inject all the dependency and then execute the method.  import { Components } from &quot;fortjs&quot;; const methodResult = Components.controller.executeMethod(&quot;UserController&quot;, &quot;createUser&quot;);  ","version":"Next","tagName":"h3"},{"title":"Format response","type":0,"sectionRef":"#","url":"/docs/advanced/format-response","content":"Format response You can customize the format of your response and based on content negotiation fortjs select the appropriate response. If an appropriate response is not found then a response with status code - 406 is returned. Let's see an example - import { Controller, http, MIME_TYPE} from &quot;fortjs&quot;; export class RandomController extends Controller { @http.get(&quot;/format&quot;) async format() { const result = { [MIME_TYPE.Json]: () =&gt; { return { message: &quot;hello world&quot; } }, [MIME_TYPE.Html]: () =&gt; { return &quot;&lt;p&gt;hello world&lt;/p&gt;&quot; }, [MIME_TYPE.Text]: () =&gt; { return &quot;hello world&quot; } }; return multiFormatResult(result); } } In the above code - we are returning three format (html, json, text).","keywords":"format response multiple response mime type fortjs node","version":"Next"},{"title":"Customize Error","type":0,"sectionRef":"#","url":"/docs/advanced/customize-error","content":"","keywords":"customize error handle error fortjs node","version":"Next"},{"title":"Create ErrorHandler​","type":1,"pageTitle":"Customize Error","url":"/docs/advanced/customize-error#create-errorhandler","content":"To customize error responses in FortJs, create a class that extends the ErrorHandler class and override the available methods. For example, if you want to customize the error response for the status code 404: import { ErrorHandler } from &quot;fortjs&quot;; export class CustomErrorHandler extends ErrorHandler { async onNotFound(url){ return htmlResult(`&lt;h1&gt;The resource ${url} does not exist.&lt;/h1&gt;`); } }  ","version":"Next","tagName":"h2"},{"title":"Use ErrorHandler​","type":1,"pageTitle":"Customize Error","url":"/docs/advanced/customize-error#use-errorhandler","content":"Once you've created the error handler class to customize HTTP responses, you need to inform FortJs about it. import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;./controllers&quot;; import { CustomErrorHandler } from &quot;./extra/custom_error_handler&quot;; //add routes Fort.routes = [{ controller: UserController, path: &quot;/user&quot; }]; Fort.errorHandler = CustomErrorHandler; Fort.create();  ","version":"Next","tagName":"h2"},{"title":"Error Handling Methods​","type":1,"pageTitle":"Customize Error","url":"/docs/advanced/customize-error#error-handling-methods","content":"When creating a custom error handler in FortJs, you have several methods that you can override to customize the handling of specific HTTP error scenarios. The available methods are: onServerError(ex: IException): Promise&lt;IHttpResult&gt; Override this method to handle server errors (Status code - 500). It is recommended not to expose exception information to users but to log the errors. onBadRequest(ex: IException): Promise&lt;IHttpResult&gt; Override this method to handle bad request errors. onForbiddenRequest(): Promise&lt;IHttpResult&gt; Override this method to handle forbidden request errors. onNotAcceptableRequest(): Promise&lt;IHttpResult&gt; Override this method to handle not acceptable request errors. onMethodNotAllowed(): Promise&lt;IHttpResult&gt; Override this method to handle method not allowed errors. onNotFound(url: string): Promise&lt;IHttpResult&gt; Override this method to handle not found errors, providing the requested URL. For example, for onServerError (Status code - 500), it's advisable not to show exception information to users but to log the errors. Note:It is highly recommended to create a custom error handler and at least override the onServerError method to log the exception. This ensures that you have information about the exceptions that occur. ","version":"Next","tagName":"h2"},{"title":"GraphQl","type":0,"sectionRef":"#","url":"/docs/advanced/graphql","content":"","keywords":"graphql integrate fortjs node","version":"Next"},{"title":"Uses​","type":1,"pageTitle":"GraphQl","url":"/docs/advanced/graphql#uses","content":"npm i fortjs-graphql or yarn add fortjs-graphqlCreate a controller and inherit GraphQlHelper Create a default worker and call processGraphQl inside it. For graphiql , create another worker and call getGraphiqlUi inside it. import { HTTP_METHOD, DefaultWorker, Worker } from &quot;fortjs&quot;; import { GraphQlHelper } from &quot;fort-graphql&quot;; export class GraphQlController extends GraphQlHelper { /** * This method will be used to process graphql query * * @returns * @memberof GraphQlController */ @DefaultWorker(HTTP_METHOD.Get, HTTP_METHOD.Post) async default() { return this.processGraphQl(); } /** * This method will return graphiql * * @returns * @memberof GraphQlController */ @Worker() async graphiql() { return this.getGraphiqlUi(); } }  Add the controller into routes Initiate the graphql, where you have bootstrapped your app. By default file is app.ts/app.js -  import { Fort } from 'fortjs'; import { routes } from './routes'; import { FortViewEngine } from 'eshtml'; import * as path from &quot;path&quot;; import { FortGraphQl } from 'fortjs-graphql'; import { GraphQLError, buildSchema } from 'graphql'; Fort.routes = routes; Fort.create({ defaultPath: &quot;default&quot; }).then(() =&gt; { console.log(&quot;Your fort is located at address - localhost:4000&quot;); // setup graphql new FortGraphQl().initiate({ schema: buildSchema(` type Query { hello: String } ` ), resolver: { hello: () =&gt; 'Hello world!' } }) }).catch(err =&gt; { console.error(err); })  ","version":"Next","tagName":"h2"},{"title":"Validator","type":0,"sectionRef":"#","url":"/docs/advanced/validator","content":"Validator We are working on this page.","keywords":"components executeMethod fortjs node","version":"Next"},{"title":"Socket.io Configuration","type":0,"sectionRef":"#","url":"/docs/advanced/socket-io","content":"Socket.io Configuration Socket.IO enables real-time, bidirectional and event-based communication. It works on every platform, browser or device, focusing equally on reliability and speed. For more info about socket.io, visit - https://socket.io/ socket.io can be injected into fortjs very easily. Let's see how ? Fortjs exposes its httpserver object and this object can be used to initiate socket.io - import { Fort } from &quot;fortjs&quot;; import { routes } from &quot;./routes&quot;; import { Server } from &quot;socket.io&quot;; const initSocketIo = () =&gt; { const io = new Server(Fort.httpServer); io.on(&quot;connection&quot;, (socket) =&gt; { Fort.logger.info(&quot;user connected&quot;); socket.on('disconnect', () =&gt; { Fort.logger.info('user disconnected'); }); socket.on('chat message', (msg) =&gt; { Fort.logger.info(`message is ${msg}`); io.emit('chat message', msg); }); }); } Fort.routes = routes; Fort.create(); We have created a method - &quot;initSocketIo&quot; which will initializes the socket.io Server using httpServer object. Here is example for implementation - Fortjs socket.io","keywords":"socket integration options fortjs node","version":"Next"},{"title":"Worker","type":0,"sectionRef":"#","url":"/docs/advanced/worker","content":"","keywords":"worker route controller method fortjs node","version":"Next"},{"title":"Creating worker​","type":1,"pageTitle":"Worker","url":"/docs/advanced/worker#creating-worker","content":"Worker is created by using decorator - worker or defaultWorker. ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Worker","url":"/docs/advanced/worker#example","content":"import { Controller, worker, defaultWorker, textResult } from &quot;fortjs&quot;; export class UserController extends Controller { @defaultWorker() async default () { return textResult(&quot;This is default worker for section user&quot;); } @worker() async getUser() { return textResult(&quot;This is a worker for section user&quot;); } }  Lets consider that controller - 'UserController' is associated with path '/user' and our domain is abc.com. So what these decorators - worker and defaultWorker do ? worker - method is added to route with all http methods (GET,POST etc) and route is '/${method_name}'. For our example - route will be : '/getuser'. defaultWorker - method having decorator defaultWorker is added to route with one http method GET. And the route is '/'. So in the above example, when url will be - abc.com/user - method default will be called.abc.com/user/getuser - method getUser will be called. ","version":"Next","tagName":"h3"},{"title":"default worker implementation​","type":1,"pageTitle":"Worker","url":"/docs/advanced/worker#default-worker-implementation","content":"A method can be declared as default worker by using decorators - worker &amp; route. Lets update the example - import { Controller, worker, textResult, HTTP_METHOD, route } from &quot;fortjs&quot;; export class UserController extends Controller { // @defaultWorker() @worker(HTTP_METHOD.Get) @route(&quot;/&quot;) async default () { return textResult(&quot;This is default worker for section user&quot;); } }  A route allows you to customize the path of worker or end point. ","version":"Next","tagName":"h2"},{"title":"View Engine","type":0,"sectionRef":"#","url":"/docs/advanced/view-engine","content":"","keywords":"view engine cutomize options fortjs node","version":"Next"},{"title":"Create a view​","type":1,"pageTitle":"View Engine","url":"/docs/advanced/view-engine#create-a-view","content":"create a file &quot;index.ejs&quot; inside the folder - &quot;views&quot;. Paste the below code inside the file - &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;%=title%&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%=msg%&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;  In the above code - title and msg will be sent from the controller and rendered by ejs view engine. Now let's pass data from Controller and call our view engine for rendering this view - export class DefaultController extends Controller { @defaultWorker() async default() { const model = { title: &quot;FortJs&quot;, msg: &quot;This is rendered by mustache&quot; }; const result = await viewResult(&quot;index.ejs&quot;, model); return result; } }  we are using viewResult to render the view, which takes - the relative location of view and model value. ","version":"Next","tagName":"h2"},{"title":"XmlParser","type":0,"sectionRef":"#","url":"/docs/advanced/xml-parser","content":"XmlParser By default FortJs doesn't handle xml data in http body but can be configured very easily. You need to create a class extending abstract class XmlParser import { XmlParser} from &quot;fortjs&quot;; export class XmlToJsonParser extends XmlParser { async parse(xml) { // convert xml to string and return a json object } } and pass this class in App configuration - import { Fort } from 'fortjs'; import { XmlToJsonParser } from './xml-parser'; Fort.xmlParser = XmlToJsonParser; You can take a look at example - xml-in-body.","keywords":"xml parser accept xml body node","version":"Next"},{"title":"Session Store","type":0,"sectionRef":"#","url":"/docs/advanced/session-store","content":"","keywords":"FortJs Session Store Custom Session Store FortJs Examples Web Development Node.js","version":"Next"},{"title":"Implement a session store​","type":1,"pageTitle":"Session Store","url":"/docs/advanced/session-store#implement-a-session-store","content":"Let's explore how to implement a simple memory session store import { ISessionStore } from &quot;fortjs&quot;; // A simple in-memory storage for session data const sessionValues: Map&lt;string, { [key: string]: any }&gt; = new Map(); export class MemorySessionStore implements ISessionStore { sessionId: string; constructor(sessionId: string) { this.sessionId = sessionId; } // Private method to get the session data associated with the current session ID private getSessionValue_() { return sessionValues.get(this.sessionId); } // Check if any session data exists async isAnyExist() { return this.getSessionValue_() != null; } // Get the value associated with a specific key in the session async get(key: string): Promise&lt;any&gt; { const savedValue = this.getSessionValue_(); return savedValue != null ? savedValue[key] : null; } // Get all session data async getAll(): Promise&lt;{ [key: string]: any }&gt; { const savedValue = this.getSessionValue_(); return savedValue || {}; } // Check if a specific key exists in the session async isExist(key: string): Promise&lt;boolean&gt; { const savedValue = this.getSessionValue_(); return savedValue == null ? false : savedValue[key] != null; } // Clear all session data for the current session ID async clear(): Promise&lt;void&gt; { // Remove session values sessionValues.delete(this.sessionId); } // Set a value for a specific key in the session async set(key: string, val: any) { const savedValue = this.getSessionValue_(); if (savedValue == null) { // If no session data exists, create a new entry sessionValues.set(this.sessionId, { [key]: val }); } else { // Update the value for an existing key savedValue[key] = val; } } // Set multiple values in the session at once async setMany(values: { [key: string]: any }) { return Promise.all( Object.keys(values).map((key) =&gt; { return this.set(key, values[key]); }) ); } // Remove a specific key from the session async remove(key: string) { const savedValue = this.getSessionValue_(); if (savedValue != null) { // Set the value to null to effectively remove it savedValue[key] = null; } } }  ","version":"Next","tagName":"h2"},{"title":"Use Session Store​","type":1,"pageTitle":"Session Store","url":"/docs/advanced/session-store#use-session-store","content":"Once you have created a session store, you need to instruct FortJs to use the new session store. import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;./controllers&quot;; import { MemorySessionStore } from &quot;./memory_session_store&quot;; // set your session provider Fort.sessionStore = MemorySessionStore //add routes Fort.routes = [{ controller: UserController, path: &quot;/user&quot; }]; Fort.create();  For a complete example, refer to the Session Store Example ","version":"Next","tagName":"h2"},{"title":"Component","type":0,"sectionRef":"#","url":"/docs/component/","content":"","keywords":"Fort.js Components Walls Shields Guards Application Structure Security Documentation","version":"Next"},{"title":"Component Flow​","type":1,"pageTitle":"Component","url":"/docs/component/#component-flow","content":"HTTP Request | Initialize Components | Execute Walls (Incoming) | | (If Wall Rejects) |----------------------| | | | Response Flow | | | |----------------------| | | (If Wall Allows) |----------------------| | | | Execute Shields | | | |----------------------| | Execute Shields | | (If Shield Rejects) |----------------------| | | | Execute Walls | | (Outgoing) | | | |----------------------| | | (If Shield Allows) |----------------------| | | | Execute Guards | | | |----------------------| | Execute Guards | | (If Guard Rejects) |----------------------| | | | Execute Walls | | (Outgoing) | | | |----------------------| | | (If Guard Allows) |----------------------| | | | Execute Controller | | Method | | | |----------------------| | Execute Controller | Execute Walls (Outgoing) | Response Flow |  👉 The above picture illustrates the architecture of a Fort.js app and the flow of an HTTP request within the app: When an HTTP request enters a Fort.js app, it embarks on a journey through a well-defined sequence of components, each playing a crucial role in the app's architecture. The journey is orchestrated as follows: Initialize Components: The app initializes its components, preparing for the incoming request. Execute Walls (Incoming): The request encounters the first line of defense, the Wall. If the Wall rejects the request, the journey concludes with a direct response flow.If the Wall allows, the request proceeds to the next phase. Execute Shields: The Shield evaluates the request, determining whether to grant access to the next stage.If the Shield rejects, the journey redirects to execute outgoing Walls, leading to the response flow.If the Shield allows, the request advances to the next component. Execute Guards: The Guard assesses the request, deciding whether it's authorized to proceed to the controller method.If the Guard rejects, the journey reroutes to execute outgoing Walls, concluding with the response flow.If the Guard allows, the request moves forward to the final phase. Execute Controller Method: The request reaches the Controller, executing the designated method that encapsulates the desired resource. Execute Walls (Outgoing): Outgoing Walls may perform additional actions before the response is sent.The journey proceeds to the final phase. Response Flow: The HTTP response is constructed, reflecting the outcomes of the entire journey through the app. In this structured and modular flow, each component contributes to the app's security, logic, and overall functionality, ensuring a robust and controlled handling of incoming HTTP requests. Summary: Not Mandatory, Highly Recommended: While it's not mandatory to create individual components, it is highly recommended. You can build your application with just Controllers and methods inside controllers, but incorporating components offers significant advantages. Components facilitate the modularization of your app into dedicated features, resulting in cleaner, more reusable, and testable code. Modularization for Clean Code: Components serve as dedicated building blocks for specific functionalities. They play a pivotal role in modularizing your application, making the codebase cleaner and more maintainable. Flexibility and Testability: Leveraging components enhances the flexibility of your application. Each component has its own lifecycle and scope, providing a clear separation of concerns. This separation not only makes the codebase more modular but also significantly improves testability. Beyond Blocking Requests: While we explored components being used to block requests in this guide, their utility extends beyond that. Components can also perform specific tasks and pass results from one component to another. For example, they can handle data validation, extract information like IP addresses, and seamlessly transfer data between different parts of the application. By embracing components, you empower your Fort.js application with a structured and modular architecture, fostering code quality, reusability, and efficient testing practices. For more details on each component's functionalities, refer to the specific documentation for each component type. ","version":"Next","tagName":"h2"},{"title":"Passport JWT Authentication","type":0,"sectionRef":"#","url":"/docs/authentication/passport/passport-jwt","content":"","keywords":"Fort.js Passport.js JWT Authentication Web Security Fort Framework","version":"Next"},{"title":"installation​","type":1,"pageTitle":"Passport JWT Authentication","url":"/docs/authentication/passport/passport-jwt#installation","content":"npm i passport-jwt  ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"Passport JWT Authentication","url":"/docs/authentication/passport/passport-jwt#registration","content":"src/index import * as path from &quot;path&quot;; import { Fort } from &quot;fortjs&quot;; import { routes } from &quot;@/routes&quot;; import { PassportAuth } from &quot;fortjs-passport&quot;; import { Strategy } from 'passport-local'; import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt'; import { db } from &quot;./services/db&quot;; export const createApp = async () =&gt; { Fort.routes = routes; // Initiate Passport authentication PassportAuth.init(); // register the jwt stategy const opts = {} as any; opts.jwtFromRequest = ExtractJwt.fromHeader('authorization'); opts.secretOrKey = 'thisisthesecretkey'; PassportAuth.passport.use('jwt', new JwtStrategy(opts, function (jwt_payload, done) { const user = db.users.find(user =&gt; user.id === jwt_payload.id); if (!user) { return done(null, false, { message: 'Not authenticated' }); } return done(null, user); } )); // Register the local strategy for user login PassportAuth.passport.use('local', new Strategy({ usernameField: 'email', passwordField: 'password' }, function (email, password, done) { const user = db.users.find(user =&gt; user.emailId === email); if (!user) { return done(null, false); } if (user.password !== password) { return done(null, false); } return done(null, user); } )); // Create the Fort application await Fort.create(); // Set the application URL process.env.APP_URL = `http://localhost:${Fort.port}`; }; if (process.env.NODE_ENV !== &quot;test&quot;) { createApp().then(() =&gt; { Fort.logger.debug(`Your fort is located at address - ${process.env.APP_URL}`); }).catch(err =&gt; { console.error(err); }); }  In the highlighted section, the JWT strategy is registered in PassportJS. This allows authentication using JSON Web Tokens (JWT) in the Fort.js application. The strategy inernally extracts the JWT from the request header and verifies it using the provided secret key. If the token is valid, it retrieves the user information from the database based on the user ID stored in the JWT payload. If the user is found, authentication is successful; otherwise, it returns an error message indicating that the user is not authenticated. ","version":"Next","tagName":"h2"},{"title":"Login​","type":1,"pageTitle":"Passport JWT Authentication","url":"/docs/authentication/passport/passport-jwt#login","content":"In case of jwt authentication - we need to create the token and send it to client either in response data or via headers. Let's change the doLogin method code from our previous example to generate the token and send the token via headers. import { http, Controller, viewResult } from &quot;fortjs&quot; import { auth } from &quot;fortjs-passport&quot;; export class AuthController extends Controller { @http.post(&quot;/login&quot;) // apply local guard which will handle the login and pass user in the method @guards(auth.guard('local')) async doLogin() { const { user } = this.request as any; const token = jwt.sign(user, 'thisisthesecretkey'); this.response.setHeader(&quot;authorization&quot;, token); return textResult(`Welcome ${user.name}`); } }  In the highlighted section, the jwt.sign function is used to generate a JWT token for the authenticated user (user) using the provided secret key ('thisisthesecretkey'). The generated token is then set in the response header with the key &quot;authorization&quot;. This allows the client to receive the token in the response headers after a successful login, enabling further authenticated requests using this token. ","version":"Next","tagName":"h2"},{"title":"Protected routes​","type":1,"pageTitle":"Passport JWT Authentication","url":"/docs/authentication/passport/passport-jwt#protected-routes","content":"In the session example - we have used auth.shield('isAuthenticated') to protect the shield, but in case of jwt auth - it won't work alone as for every request the token needs to be parsed and then extract the payload from the token which means calling jwt-strategy for each request. For calling jwt-strategy : we will use auth.shield and pass the strategy name jwt. import { Controller, shields, http, jsonResult } from &quot;fortjs&quot;; import { auth } from 'fortjs-passport'; @shields(auth.shield(&quot;jwt&quot;,{ session: false})) export class ProtectedController extends Controller { @http.get(&quot;/user&quot;) getUser(){ // isAuthenticated shield pass `user` via data. const { user } = this.data; // const user = this.request['user'] - this is how you would get user in expressjs return jsonResult(user); } }  In the highlighted section, @shields(auth.shield(&quot;jwt&quot;, { session: false })) is used to apply the JWT authentication shield to protect the route. The { session: false } option is passed to the shield to ensure that the session is not used, as JWT is a stateless authentication method. This shield validates the incoming JWT token for each request and extracts the user information for further processing in the route handler. tip You can store the auth.shield result in a variable and use it wherever its needed. For example - const JWT_SHIELD = auth.shield(&quot;jwt&quot;,{ session: false}); and then use it - @shields(JWT_SHIELD) export class ProtectedController extends Controller { }  ","version":"Next","tagName":"h2"},{"title":"Authentication","type":0,"sectionRef":"#","url":"/docs/authentication/","content":"","keywords":"Fort.js Authentication Web Framework Documentation Node.js Authentication User Session Web Application Security","version":"Next"},{"title":"Requirements​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#requirements","content":"In every web application, it's essential to include the following common logic: ","version":"Next","tagName":"h2"},{"title":"1. Registration and Login Routes​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#1-registration-and-login-routes","content":"1.1 Registration Page​ Route: /register (GET)Description: This route renders an HTML page allowing users to register for the application. 1.2 Login Page​ Route: /login (GET)Description: Accessing this route will display an HTML page for user login. ","version":"Next","tagName":"h3"},{"title":"2. User Login​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#2-user-login","content":"2.1 Login Post Route​ Route: /login (POST)Description: Users can submit their credentials through a POST request to this route for authentication. ","version":"Next","tagName":"h3"},{"title":"3. Protected Routes​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#3-protected-routes","content":"3.1 Protected Route​ Route: /protected (GET)Description: Access to this route is restricted to authenticated users only. By implementing these routes, users can seamlessly register, log in, and access protected areas within the application. ","version":"Next","tagName":"h3"},{"title":"Implementation​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#implementation","content":"Consider the following scenario: a registered user possesses a user ID and password, granting access to the system upon entering valid credentials. Our application includes a AuthController featuring a login page, a registration page. Notably, this AuthController is accessible to anyone without requiring a login. ","version":"Next","tagName":"h2"},{"title":"Create Controller​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#create-controller","content":"Let's Create a controller named AuthController which is mapped with route &quot;/auth&quot;. This route is accessible to everyone without any authentication. src/controllers/auth_controller import { Controller } from &quot;fortjs&quot; export class AuthController extends Controller { }  src/routes import { AuthController } from &quot;@/controllers/auth_controller&quot;; export const routes = [{ path: &quot;/auth&quot;, controller: AuthController }]  ","version":"Next","tagName":"h3"},{"title":"Registration and Login get routes​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#registration-and-login-get-routes","content":"import { http, Controller, viewResult } from &quot;fortjs&quot; export class AuthController extends Controller { // Route for rendering the login page @http.get(&quot;/login&quot;) async getLoginPage() { const result = viewResult(&quot;loginPage&quot;); return result; } // Route for rendering the registration page @http.get(&quot;/register&quot;) async getRegisterPage() { const result = viewResult(&quot;registerPage&quot;); return result; } }  In the AuthController, two routes, /login and /register, are defined with the GET HTTP method. The getLoginPage method renders the login page, and the getRegisterPage method renders the registration page using the viewResult function. For information on how viewResult works, refer to viewResult Doc. ","version":"Next","tagName":"h3"},{"title":"User Login​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#user-login","content":"import { http, Controller, textResult, viewResult } from &quot;fortjs&quot;; export class AuthController extends Controller { @http.get(&quot;/login&quot;) async getLoginPage() { const result = viewResult(&quot;loginPage&quot;); return result; } @http.get(&quot;/register&quot;) async getRegisterPage() { const result = viewResult(&quot;registerPage&quot;); return result; } @http.post(&quot;/login&quot;) async doLogin() { const {emailId, password} = this.body; const userService = new UserService(); const user = userService.getUserByEmail(emailId); if (user != null &amp;&amp; user.password === pwd) { this.session.set('userId', user.id); this.session.set('emailId', emailId); return textResult(`Authenticated`); } else { return textResult(&quot;Invalid credential&quot;); } } }  In the highlighted code, a doLogin: method is created which is responsible for the login process through a POST request. It retrieves the email ID and password from the request body, validates whether the provided credentials are correct, and, if so, creates a session. When a session is established, the framework generates a cookie and sends it to the browser. The framework subsequently tracks the user using this cookie. Once a session has been established for a user, it becomes accessible throughout the system, including any controller or component, using this.session. For example: // Get userId from the session this.session.get('userId'); // Check if the session exists this.session.isExist('userId');  These methods allow convenient retrieval of user-related information stored in the session. ","version":"Next","tagName":"h3"},{"title":"Restricting User Access to resource​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#restricting-user-access-to-resource","content":"To prevent unauthenticated users from accessing restricted methods, a common practice is to check the session in every method. If the session is set, proceed with the request; otherwise, redirect to the login page or send a text response with HTTP code 401. However, this logic tends to be repetitive and can be extracted into a common method for reuse. Fort.js facilitates this through components. Depending on the specific requirements, you can use Shield or Guard. info Shields allow you to protect your controller, ensuring that only authorized users can access it. Guards, on the other hand, enable you to protect your controller methods, adding an additional layer of authorization at the method level. Let's consider the scenario where we want to restrict access at the controller level. To achieve this, we'll create an Shield named AuthenticationShield. We'll encapsulate our authentication logic within this shield. ","version":"Next","tagName":"h2"},{"title":"Creating Shield​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#creating-shield","content":"To create the AuthenticationShield, we need to define a class that extends the Shield class from Fortjs. import { Shield, textResult } from &quot;fortjs&quot;; export class AuthenticationShield extends Shield { async protect() { const isExist = await this.session.isExist('userId'); if(!exist) { //user is not authenticated, so return error message with 401 return textResult(&quot;Not authenticated&quot;, 401); } // returning nothing or null means shield has allowed } }  ","version":"Next","tagName":"h3"},{"title":"Using shield for protected routes​","type":1,"pageTitle":"Authentication","url":"/docs/authentication/#using-shield-for-protected-routes","content":"Now, we can add this shield to any controllers where authorization or protection of route is required. Let's incorporate this into a new controller named - ProtectedController mapped with route /protected To utilize the shield, the shields decorator is used, which can accept multiple shields. src/controller/protected_controller import { Controller, shields } from &quot;fortjs&quot;; import { AuthenticationShield } from &quot;@/shields&quot;; @shields(AuthenticationShield) export class ProtectedController extends Controller { }  src/routes import { AuthController } from &quot;@/controllers/auth_controller&quot;; import { ProtectedController } from &quot;@/controllers/protected_controller&quot;; export const routes = [ { path: &quot;/auth&quot;, controller: AuthController }, { path: &quot;/protected&quot;, controller: ProtectedController } ]  Now, our AuthenticationShield will safeguard the ProtectedController from unauthorized access. Any attempt by an unauthenticated user to access the ProtectedController will result in an unauthenticated error response, as defined in the shield logic. Similarly, you can create a Guard to restrict access at the controller method level. For a complete example, refer to the Authentication Example. tip 👉 In this documentation, we've demonstrated how to use Shields to restrict access to a controller, specifically for session authentication. However, the same logic can be applied to other types of authentication, such as Basic Authentication or JWT Authentication. If you encounter any challenges or need assistance, feel free to ask in the GitHub discussion channel. In the next chapter, we will learn about using passportjs in fortjs - a famous express library for authentication. ","version":"Next","tagName":"h3"},{"title":"Guard","type":0,"sectionRef":"#","url":"/docs/component/guard","content":"","keywords":"Fort.js Guard Access Control Security Documentation","version":"Next"},{"title":"Use Cases​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#use-cases","content":"Data validation at the method level.Authentication at the controller method level.Performing tasks and passing them to the Worker. ","version":"Next","tagName":"h2"},{"title":"Multiple Guards​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#multiple-guards","content":"Multiple guards can be assigned to a Worker, and they are called in the same order as declared. ","version":"Next","tagName":"h2"},{"title":"Guard members​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#guard-members","content":"A guard has following member - RequestResponseCookieSessionQuery dataBody dataRoute parameterData from other components ","version":"Next","tagName":"h2"},{"title":"Creating a Guard​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#creating-a-guard","content":"A Guard is a class that extends the Guard class from Fort.js. It has a check method as its lifecycle. ","version":"Next","tagName":"h2"},{"title":"Lifecycle Method​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#lifecycle-method","content":"The check method can perform various tasks, such as validation, and return the result. It can return two types of data: null - It means the guard has passed the request.HTTP response - It means the guard has rejected the request. The HTTP response is directly returned to the user. Explore the powerful capabilities of Guards by implementing them in your Fort.js application. ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#example","content":"Let's create a Guard that validates user data sent in the HTTP body. It will allow the request to proceed if the user is valid and reject it otherwise. import { Guard, HttpResult, MIME_TYPE, HTTP_STATUS_CODE } from &quot;fortjs&quot;; import {isEmail, isLength, isIn} from &quot;validator&quot;; export class ValidUserGuard extends Guard { async check() { const user = { // extracted the info from request body name: this.body.name, gender: this.body.gender, address: this.body.address, emailId: this.body.emailId }; const errMsg = this.validate(user); if (errMsg == null) { // pass user to worker method, so that they dont need to parse again this.data.user = user; return null; // Guard allows the request to pass } else { return textResult(errMsg, HTTP_STATUS_CODE.BadRequest); } } validate(user) { let errMessage; if (user.name == null || !isLength(user.name, 5)) { errMessage = &quot;name should be minimum 5 characters&quot; } else if (user.password == null || !isLength(user.password, 5)) { errMessage = &quot;password should be minimum 5 characters&quot;; } else if (user.gender == null || !isIn(user.gender, [&quot;male&quot;, &quot;female&quot;])) { errMessage = &quot;gender should be either male or female&quot;; } else if (user.gender == null || !isEmail(user.emailId)) { errMessage = &quot;email not valid&quot;; } else if (user.address == null || !isLength(user.address, 10, 100)) { errMessage = &quot;address length should be between 10 &amp; 100&quot;; } return errMessage; } }  Now you can use this guard on any controller method: import { Controller, guards } from &quot;fortjs&quot;; import { ValidUserGuard } from &quot;@/guards&quot;; export class UserController extends Controller { @guards(ValidUserGuard) addUser(){ const user = this.data.user ; } }  This guard will validate the user data before allowing the request to proceed to the addUser method in the UserController. ","version":"Next","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Guard","url":"/docs/component/guard#summary","content":"Guards enable the extraction of reusable logic such as validation and authentication.Guards can be independently used by multiple controller methods, enhancing code reusability.The use of guards contributes to cleaner code structures.Guards can be independently unit-tested, ensuring reliability in isolation. ","version":"Next","tagName":"h2"},{"title":"Passportjs integration","type":0,"sectionRef":"#","url":"/docs/authentication/passport/","content":"","keywords":"Fort.js Passport.js Authentication JWT Sessions Express.js","version":"Next"},{"title":"Requirements​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#requirements","content":"In every web application, it's essential to include the following common logic: ","version":"Next","tagName":"h2"},{"title":"1. Registration and Login Routes​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#1-registration-and-login-routes","content":"1.1 Registration Page​ Route: /register (GET)Description: This route renders an HTML page allowing users to register for the application. 1.2 Login Page​ Route: /login (GET)Description: Accessing this route will display an HTML page for user login. ","version":"Next","tagName":"h3"},{"title":"2. User Login​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#2-user-login","content":"2.1 Login Post Route​ Route: /login (POST)Description: Users can submit their credentials through a POST request to this route for authentication. ","version":"Next","tagName":"h3"},{"title":"3. Protected Routes​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#3-protected-routes","content":"3.1 Protected Route​ Route: /protected (GET)Description: Access to this route is restricted to authenticated users only. By implementing these routes, users can seamlessly register, log in, and access protected areas within the application. ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#installation","content":"Our first step involves installing the necessary packages. Passport offers a strategy named passport-local, specifically designed for username/password authentication — a fitting choice for this phase of our use case. npm i fortjs-passport passport-local  You have the option to install typings for passport-local, although it's not mandatory. npm i @types/passport-local -D  ","version":"Next","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#implementation","content":"","version":"Next","tagName":"h2"},{"title":"Initiate​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#initiate","content":"src/index import * as path from &quot;path&quot;; import { Fort } from &quot;fortjs&quot;; import { routes } from &quot;@/routes&quot;; import { PassportAuth } from &quot;fortjs-passport&quot;; import { Strategy } from 'passport-local'; import { db } from &quot;./services/db&quot;; export const createApp = async () =&gt; { Fort.routes = routes; // Initiate Passport authentication PassportAuth.init(); // Register the local strategy for user login PassportAuth.passport.use('local', new Strategy({ usernameField: 'email', passwordField: 'password' }, function (email, password, done) { const user = db.users.find(user =&gt; user.emailId === email); if (!user) { return done(null, false); } if (user.password !== password) { return done(null, false); } return done(null, user); } )); // Create the Fort application await Fort.create(); // Set the application URL process.env.APP_URL = `http://localhost:${Fort.port}`; }; if (process.env.NODE_ENV !== &quot;test&quot;) { createApp().then(() =&gt; { Fort.logger.debug(`Your fort is located at address - ${process.env.APP_URL}`); }).catch(err =&gt; { console.error(err); }); }  In the provided code snippet, the Passport module is initialized using PassportAuth.init(), and a local strategy is registered for user login authentication. The configuration includes specifying the username and password fields. The createApp function is responsible for setting up the Fort application, and the application URL is logged once the setup is complete. info You can get the passport instance by PassportAuth.passport and use it for almost everything as you would do in express application. ","version":"Next","tagName":"h3"},{"title":"Create Controller​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#create-controller","content":"Let's Create a controller named AuthController which is mapped with route &quot;/auth&quot;. This route is accessible to everyone without any authentication. src/controllers/auth_controller import { Controller } from &quot;fortjs&quot; export class AuthController extends Controller { }  src/routes import { AuthController } from &quot;@/controllers/auth_controller&quot;; export const routes = [{ path: &quot;/auth&quot;, controller: AuthController }]  ","version":"Next","tagName":"h3"},{"title":"Registration and Login routes​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#registration-and-login-routes","content":"import { http, Controller, viewResult } from &quot;fortjs&quot; export class AuthController extends Controller { // Route for rendering the login page @http.get(&quot;/login&quot;) async getLoginPage() { const result = viewResult(&quot;loginPage&quot;); return result; } // Route for rendering the registration page @http.get(&quot;/register&quot;) async getRegisterPage() { const result = viewResult(&quot;registerPage&quot;); return result; } }  In the AuthController, two routes, /login and /register, are defined with the GET HTTP method. The getLoginPage method renders the login page, and the getRegisterPage method renders the registration page using the viewResult function. For information on how viewResult works, refer to viewResult Doc. ","version":"Next","tagName":"h3"},{"title":"User Login​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#user-login","content":"import { http, Controller, viewResult } from &quot;fortjs&quot; import { auth } from &quot;fortjs-passport&quot;; export class AuthController extends Controller { @http.post(&quot;/login&quot;) // apply local guard which will handle the login and pass user in the method @guards(auth.guard('local')) async doLogin() { const { user } = this.request as any; return textResult(`Welcome ${user.name}`); } // Route for rendering the login page @http.get(&quot;/login&quot;) async getLoginPage() { const result = viewResult(&quot;loginPage&quot;); return result; } // Route for rendering the registration page @http.get(&quot;/register&quot;) async getRegisterPage() { const result = viewResult(&quot;registerPage&quot;); return result; } }  In the provided code snippet, a POST route for user login has been implemented using the @http.post decorator. The @guards(auth.guard('local')) decorator is applied to handle the login process using the local strategy. The user object is then accessed from the request, and a welcome message is returned in the response. info The auth property from fortjs-passport can be utilized to execute the Passport strategy by providing the registered strategy name. It exposes two key functions: auth.guard and auth.shield. These functions streamline the usage of Passport's authentication features within the Fort.js application. tip By default, fortjs-passport initializes sessions for you to enable persistent authentication. However, you have the option to turn off session support by setting Fort.shouldParseCookie to false. This action disables cookie parsing, consequently turning off the session functionality. ","version":"Next","tagName":"h3"},{"title":"Protected route​","type":1,"pageTitle":"Passportjs integration","url":"/docs/authentication/passport/#protected-route","content":"Let's create a controller named - ProtectedController with route /protected. It will have some endpoints and will be accessible to only authenticated user. src/controller/protected_controller import { Controller, shields } from &quot;fortjs&quot;; import { auth } from 'fortjs-passport'; @shields(auth.shield(&quot;isAuthenticated&quot;)) export class ProtectedController extends Controller { }  src/routes import { AuthController } from &quot;@/controllers/auth_controller&quot;; import { ProtectedController } from &quot;@/controllers/protected_controller&quot;; export const routes = [ { path: &quot;/auth&quot;, controller: AuthController }, { path: &quot;/protected&quot;, controller: ProtectedController } ]  In the provided code snippet, a ProtectedController is created with the route /protected. The controller is protected by the isAuthenticated shield, which is applied using auth.shield(&quot;isAuthenticated&quot;). This shield ensures that only authenticated users have access to the endpoints within the ProtectedController. Access user​ Let's create a controller method named - getUser which is mapped with route /user and http method GET. It will return the user object as json. import { Controller, shields, http, jsonResult } from &quot;fortjs&quot;; import { auth } from 'fortjs-passport'; @shields(auth.shield(&quot;isAuthenticated&quot;)) export class ProtectedController extends Controller { @http.get(&quot;/user&quot;) getUser(){ // isAuthenticated shield pass `user` via data. const { user } = this.data; // const user = this.request['user'] - this is how you would get user in expressjs return jsonResult(user); } }  For a complete example, refer to the Passportjs session Auth Example. 👉 In the next chapter, we will learn how to implement JWT Authentication using passportjs. ","version":"Next","tagName":"h3"},{"title":"Shield","type":0,"sectionRef":"#","url":"/docs/component/shield","content":"","keywords":"Fort.js Shields Security Layers Authentication Authorization Rate Limiting Input Validation Request Logging Maintenance Mode CORS Handling IP Whitelisting IP Blacklisting Fort.js Security Web Application Security","version":"Next"},{"title":"Creating shield​","type":1,"pageTitle":"Shield","url":"/docs/component/shield#creating-shield","content":"A Shield is a class that extends the Shield class from Fort.js. It has a protect method as the lifecycle of the Shield. The protect method can perform any task, such as validation, and return the result. The method can return two types of data: null - It means the shield has passed the request.HTTP response - It means the shield has rejected the request. The HTTP response is returned to the wallOutgoing event and then directly returned to the user. ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Shield","url":"/docs/component/shield#example","content":"import { Shield, textResult } from &quot;fortjs&quot;; export class AuthenticationShield extends Shield { async protect() { const isExist = await this.session.isExist('userId'); if(!exist) { //user is not authenticated, so return error message with 401 return textResult(&quot;Not authenticated&quot;, 401); } // returning nothing or null means shield has allowed } }  ","version":"Next","tagName":"h3"},{"title":"Using Shield​","type":1,"pageTitle":"Shield","url":"/docs/component/shield#using-shield","content":"Now let's use this shield to some controller. import { Controller, shields } from &quot;fortjs&quot;; import { AuthenticationShield } from &quot;@/shields&quot;; @shields(AuthenticationShield) export class UserController extends Controller { }  ","version":"Next","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Shield","url":"/docs/component/shield#summary","content":"A shield allows you to execute logic before accessing the controller.It can be used for controller-level tasks like authentication, etc.A shield can be assigned to multiple controllers. For example, an authorization shield can be placed on all controllers where authentication is required. ","version":"Next","tagName":"h2"},{"title":"Use case​","type":1,"pageTitle":"Shield","url":"/docs/component/shield#use-case","content":"Certainly! Here are some common use cases for using shields in a Fort.js application: Authentication: You can use a shield to check whether a user is authenticated before allowing access to a controller. If the authentication fails, the shield can reject the request. Authorization: Shields can be employed to check whether a user has the necessary permissions to perform a specific action. If the user lacks the required permissions, the shield can reject the request. Rate Limiting: Implementing rate limiting logic to control the number of requests a user can make within a certain timeframe. If the user exceeds the limit, the shield can reject the request. Input Validation: Shields can be used to validate incoming data before it reaches the controller. If the data does not meet certain criteria, the shield can reject the request. Maintenance Mode: A shield can be employed to check whether the application is in maintenance mode. If it is, the shield can reject requests and return a maintenance message. IP Whitelisting/Blacklisting: Controlling access based on the IP address of the incoming request. Shields can reject requests from blacklisted IPs or allow requests only from whitelisted IPs. These are just a few examples, and the flexibility of shields allows developers to implement various custom logic to meet the specific requirements of their applications. ","version":"Next","tagName":"h2"},{"title":"HTTP Body","type":0,"sectionRef":"#","url":"/docs/concepts/body","content":"","keywords":"request body post data body http body nodejs","version":"Next"},{"title":"Body Parsing Configuration​","type":1,"pageTitle":"HTTP Body","url":"/docs/concepts/body#body-parsing-configuration","content":"By default, Fort.js parses the body data. However, you can turn off this feature by setting the option - shouldParseBody. Please refer to the bootstrap documentation for more information. // In your bootstrap file Fort.shouldParseBody = false;  ","version":"Next","tagName":"h2"},{"title":"Inject Body Data​","type":1,"pageTitle":"HTTP Body","url":"/docs/concepts/body#inject-body-data","content":"You can inject body data into components or controller methods for easy access to HTTP request body data. To achieve this, use the @asBody decorator. import { Controller, http, textResult, asBody } from &quot;fortjs&quot;; export class UserController extends Controller { @http.post(&quot;/create&quot;) async createUser(@asBody user) { // The 'user' parameter now contains the data from the HTTP request body console.log(user); // Your logic for creating a user // ... return textResult(&quot;User created successfully&quot;); } }  In this example, the @asBody() decorator is used on the user parameter of the createUser method. This automatically injects the data from the HTTP request body into the user parameter. You can then use this data within your method to perform the desired logic, such as creating a user in this case. Please ensure that the structure of the user object aligns with the expected format and content of the data sent in the HTTP request body. tip In typescript: you can assign a type to user variable. For example - import { UserDTO } from &quot;@/models&quot;; async createUser(@asBody user: UserDTO) { }  ","version":"Next","tagName":"h2"},{"title":"Wall","type":0,"sectionRef":"#","url":"/docs/component/wall","content":"","keywords":"wall HTTP Request Control Gatekeeper CORS Headers","version":"Next"},{"title":"Use cases​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#use-cases","content":"Setting cors Counting no of requestsCalculating some global data like ip address of the client ","version":"Next","tagName":"h2"},{"title":"Wall members​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#wall-members","content":"A wall has following member- RequestResponseCookieSessionQuery dataData from other components ","version":"Next","tagName":"h2"},{"title":"Wall Events​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#wall-events","content":"A Wall in Fortjs has two essential events: ","version":"Next","tagName":"h2"},{"title":"onIncoming​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#onincoming","content":"Description: Called when a request is initiated.If this event returns null, it means the request is allowed to enter. Otherwise, it is rejected with the returned result. Sequential Execution: If there are multiple walls, the onIncoming event is called in the order they are defined. ","version":"Next","tagName":"h3"},{"title":"onOutgoing​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#onoutgoing","content":"Description: Called when a request has been executed from component lifecycles.This event is optional, and the result returned from this event is ignored.onOutgoing is invoked with the returned response, allowing you to perform actions such as adding/removing headers or modifying the result. Sequential Execution: If there are multiple walls, the onOutgoing event is called in reverse order from how they are defined. These events provide hooks for executing custom logic during the incoming and outgoing phases of a request's lifecycle. They enhance the flexibility of Walls in managing the flow and behavior of your Fort.js application. ","version":"Next","tagName":"h3"},{"title":"Creating wall​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#creating-wall","content":"A Wall is a class which extends the class &quot;Wall&quot; from fortjs. import { Wall } from &quot;fortjs&quot; export class AppWall extends Wall { async onIncoming() { console.log(&quot;request is asking for entering into the fort&quot;); if (some condition) { // block request return textResult(&quot;This request is blocked by wall&quot;); } else { // allow request return null; } } async onOutgoing(result) { // can be used to set headers, log events, modify returning result etc console.log(&quot;request finished with result&quot;, result); } }  To use your custom wall, open the app.ts`` (or app.js`) file and add your wall to the walls` array. import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;./controllers&quot;; import { AppWall } from &quot;./walls/app_wall&quot;; //add routes Fort.routes = [{ controller: UserController, path: &quot;/user&quot; }] // adding AppWall to the walls array Fort.walls = [AppWall]  ","version":"Next","tagName":"h2"},{"title":"Use case examples​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#use-case-examples","content":"","version":"Next","tagName":"h2"},{"title":"Setting cors​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#setting-cors","content":"import { Wall } from 'fortjs'; export class HeaderWall extends Wall { // This Wall is designed to handle CORS (Cross-Origin Resource Sharing) by setting appropriate headers async onIncoming() { // Set headers for CORS handling this.response.setHeader( 'Access-Control-Allow-Headers', 'Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, Workspaceid', ); this.response.setHeader('Access-Control-Allow-Credentials', 'true'); this.response.setHeader('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS, PATCH'); // Define allowed hosts const ALLOWED_HOSTS = [ 'http://localhost:8080' ]; // Check if the request origin is allowed const { origin } = this.request.headers; if (ALLOWED_HOSTS.indexOf(origin as string) &gt;= 0) { this.response.setHeader('Access-Control-Allow-Origin', origin); } } }  ","version":"Next","tagName":"h3"},{"title":"Pass ip address of the incoming request to other components​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#pass-ip-address-of-the-incoming-request-to-other-components","content":"import { Wall, textResult, HttpResult, assign } from &quot;fortjs&quot;; export class RequestLogger extends Wall { private getIP(req) { const ip = (req.headers['x-forwarded-for'] || '').split(',').pop() || req.connection.remoteAddress || req.socket.remoteAddress || req.connection.socket.remoteAddress; return ip; } async onIncoming() { this.data.ip = this.getIP(this.request); } }  In the above snippet, we are evaluating the IP address of the incoming request inside the onIncoming method of the wall. The obtained IP address is then set to the data property of the wall. This data value is passed to subsequent components, including controller methods, in the request flow. ","version":"Next","tagName":"h3"},{"title":"How to modify returning result​","type":1,"pageTitle":"Wall","url":"/docs/component/wall#how-to-modify-returning-result","content":"The returning result of the request can be modified in onOutgoing method by replacing with a custom http result. class AppWall extends Wall { async onIncoming() { return null; } async onOutgoing(result) { Object.assign(result, textResult(&quot;result modified by wall outgoing&quot;); } }  ","version":"Next","tagName":"h3"},{"title":"Cookie","type":0,"sectionRef":"#","url":"/docs/concepts/cookie","content":"Cookie cookie is class member of Wall, Guard , Shield and Controller. Let's see how we can use cookie - import { Controller, defaultWorker textResult } from &quot;fortjs&quot;; export class DefaultController extends Controller { @defaultWorker() async default() { // check exist const isCookieExist = this.cookie.isExist('cookie_name'); // get cookie const cookie = this.cookie.getCookie('cookie_name'); //add cookie const newCookie = new HttpCookie('new_cookie','cookie_value'); this.cookie.addCookie(newCookie); //remove cookie this.cookie.removeCookie('cookie_name'); return textResult(&quot;Hey, we have tested cookie successfully&quot;); } } In the same way you can access cookie in Wall, Guard and Shield.","keywords":"cookie http manipulation fortjs node","version":"Next"},{"title":"Data","type":0,"sectionRef":"#","url":"/docs/concepts/data","content":"","keywords":"data components options fortjs node","version":"Next"},{"title":"Pass data from Wall​","type":1,"pageTitle":"Data","url":"/docs/concepts/data#pass-data-from-wall","content":"import { Wall, textResult } from &quot;fortjs&quot;; export class RequestLogger extends Wall { private getIP(req) { var ip = (req.headers['x-forwarded-for'] || '').split(',').pop() || req.connection.remoteAddress || req.socket.remoteAddress || req.connection.socket.remoteAddress return ip; } async onIncoming() { // here we are sending ip to other components this.data.ip = this.getIP(this.request); return null; } }  The above wall is using data to pass ip to other components. ","version":"Next","tagName":"h2"},{"title":"Access data passed from Wall in Controller​","type":1,"pageTitle":"Data","url":"/docs/concepts/data#access-data-passed-from-wall-in-controller","content":"import { Controller, textResult, defaultWorker } from &quot;fortjs&quot;; export class DefaultController extends Controller { @defaultWorker() async default() { // access ip const ip = this.data.ip; return textResult(`Ip is ${ip}`); } }  ","version":"Next","tagName":"h2"},{"title":"Dependency Injection","type":0,"sectionRef":"#","url":"/docs/concepts/dependency-injection","content":"","keywords":"Dependency Injection singleton assign JavaScript framework Web development Code modularity Unit testing","version":"Next"},{"title":"singleton​","type":1,"pageTitle":"Dependency Injection","url":"/docs/concepts/dependency-injection#singleton","content":"The singleton decorator in Fort.js allows you to inject a class dependency and maintain a single instance of that class throughout the entire application. This helps optimize memory usage by creating only one instance of the class, which is reused wherever it is injected. ","version":"Next","tagName":"h2"},{"title":"Inject into constructor​","type":1,"pageTitle":"Dependency Injection","url":"/docs/concepts/dependency-injection#inject-into-constructor","content":"Let's illustrate how to use singleton by injecting a UserService class into a controller's constructor: import { Controller, singleton } from &quot;fortjs&quot;; import { UserService } from &quot;@/services&quot;; export class UserController extends Controller { service: UserService; constructor(@singleton(UserService) service) { super(); this.service = service; } }  In this example, the UserService class is injected into the UserController as a singleton. This ensures that the same instance of UserService is utilized throughout the entire application, promoting efficient memory management. ","version":"Next","tagName":"h3"},{"title":"Inject into controller methods​","type":1,"pageTitle":"Dependency Injection","url":"/docs/concepts/dependency-injection#inject-into-controller-methods","content":"The dependency injection can be also performed on controller methods or any component methods which is called by framework. import { Controller, singleton, http } from &quot;fortjs&quot;; import { UserService } from &quot;@/services&quot;; export class UserController extends Controller { service: UserService; constructor(@singleton(UserService) service) { super(); this.service = service; } @http.post(&quot;/&quot;) addUser(@singleton(UserService) service){ } }  In the above code snippet, the UserService is injected into both the constructor and the addUser method of the UserController. Since the @singleton decorator is used, only one instance of the UserService will be shared among the entire application. This ensures a single, shared instance of the service, promoting consistency and efficient memory usage. ","version":"Next","tagName":"h3"},{"title":"assign​","type":1,"pageTitle":"Dependency Injection","url":"/docs/concepts/dependency-injection#assign","content":"The assign decorator in Fort.js allows you to inject a specific value into a variable in a controller or any type of component. Here's an example of injecting the value &quot;hello world&quot; into a variable using the assign decorator in a controller: import { Controller, assign, http } from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/&quot;) index(@assign('hello world') value) { console.log(value); // Output: hello world } }  In this example, the assign decorator injects the value &quot;hello world&quot; into the value variable. This provides a flexible way to assign specific values to variables within your components. ","version":"Next","tagName":"h2"},{"title":"Summary​","type":1,"pageTitle":"Dependency Injection","url":"/docs/concepts/dependency-injection#summary","content":"@singleton allows injection of a class dependency with a single instance maintained throughout the app.@assign injects specific values into variables, providing flexibility for assigning values in components. ","version":"Next","tagName":"h2"},{"title":"File Handling","type":0,"sectionRef":"#","url":"/docs/concepts/file","content":"","keywords":"Fort.js File Handling File Upload Web Development","version":"Next"},{"title":"File Upload​","type":1,"pageTitle":"File Handling","url":"/docs/concepts/file#file-upload","content":"Let's explore the process of uploading a file in Fort.js: import { Controller, textResult, http } from &quot;fortjs&quot;; import * as Path from &quot;path&quot;; export class FileController extends Controller { @http.post(&quot;/upload&quot;) async uploadFile() { let result; // Check if a file exists in the HTTP request if (this.file.isExist('jsstore') === true) { // Save the file to the desired location const pathToSave = Path.join(__dirname, &quot;../upload.png&quot;); // Supply the filename from the request and the path to save await this.file.saveTo('jsstore', pathToSave); result = &quot;File saved&quot;; } else { result = &quot;File not saved&quot;; } return textResult(result); } }  In this example, the uploadFile method handles file uploads. It checks if a file named 'jsstore' is present in the HTTP request. If the file exists, it is saved to a specified location. Adjust the filename and path as needed for your application. The process ensures a seamless file upload mechanism in Fort.js. ","version":"Next","tagName":"h2"},{"title":"Middleware","type":0,"sectionRef":"#","url":"/docs/concepts/middleware","content":"","keywords":"middleware pattern fortjs node","version":"Next"},{"title":"How to use in fortjs​","type":1,"pageTitle":"Middleware","url":"/docs/concepts/middleware#how-to-use-in-fortjs","content":"every component has access to request and response object. Thus you can use any middleware inside the component and you have the control how to use &amp; in what order. ","version":"Next","tagName":"h2"},{"title":"Using helmet​","type":1,"pageTitle":"Middleware","url":"/docs/concepts/middleware#using-helmet","content":"Let's see how to use helmetjs inside component wall - import { Wall, textResult } from &quot;fortjs&quot;; import * as helmet from 'helmet'; export class HelmetWall extends Wall { async onIncoming() { const result = await this.callMiddleWare(helmet()); } callMiddleWare(middleWare) { return new Promise((res, rej) =&gt; { middleWare(this.request, this.response, res); }); } }  In a similar way other middleware can be used in any component. You can download example from here - Middleware example For detailed information visit this article - https://medium.com/fortjs/middleware-pattern-in-fortjs-7329cc7cf499 written by Ujjwal Gupta ","version":"Next","tagName":"h3"},{"title":"Logger","type":0,"sectionRef":"#","url":"/docs/concepts/logger","content":"","keywords":"logger customisation node","version":"Next"},{"title":"Customize​","type":1,"pageTitle":"Logger","url":"/docs/concepts/logger#customize","content":"You might want to log everything in files or database, so want to customize the default logger. Logger can be customized very easily by creating a class &amp; extending Logger import { Logger } from 'fortjs'; export class CustomLogger extends Logger { debug(message) { // do anything with message } }  Now you need to tell framework to use your logger - import { Fort } from 'fortjs'; Fort.logger = CustomLogger;  Logger has following methods available - debug(...args)info(...args)error(...args)log(...args) Since you are extending, you can create your own method too. For more help - You can see examples for winston implementation : https://github.com/ujjwalguptaofficial/fortjs/tree/master/example/winston ","version":"Next","tagName":"h2"},{"title":"param","type":0,"sectionRef":"#","url":"/docs/concepts/param","content":"","keywords":"param route url param fortjs node","version":"Next"},{"title":"Inject Path Parameters​","type":1,"pageTitle":"param","url":"/docs/concepts/param#inject-path-parameters","content":"You can inject path parameters into components or controller methods for easy access to values specified in the URL path. To achieve this, use the @asParam decorator. import { Controller, http, textResult, asParam } from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/user/:userId&quot;) async getUserById(@asParam() params) { // The 'params' object contains all path parameters const userId = params.userId; console.log(userId); // Your logic for processing user information based on the user ID // ... return textResult(`User information for ID ${userId} retrieved successfully`); } }  In this corrected example, the @asParam() decorator without any arguments injects the entire params object. You can then access specific path parameters using their names as properties of the params object, such as params.userId in this case. ","version":"Next","tagName":"h2"},{"title":"View","type":0,"sectionRef":"#","url":"/docs/concepts/view","content":"","keywords":"view render fortjs node","version":"Next"},{"title":"viewResult​","type":1,"pageTitle":"View","url":"/docs/concepts/view#viewresult","content":"A view is rendered using the method viewResult. The viewResult accepts two parameters - view identification - view location or view name or idmodel Let's see an example - import { defaultWorker, viewResult } from &quot;fortjs&quot; export class DefaultController extends Controller { @defaultWorker() async default() { const model = { title: 'FortJs' } const result = await viewResult('default/index.html',model); return result; } }  By default fortjs provides mustache as view engine. But any view engine like - handlebar, ejs etc can be used. For configuring other view engine, please read the docs - viewEngine ","version":"Next","tagName":"h2"},{"title":"Session","type":0,"sectionRef":"#","url":"/docs/concepts/session","content":"","keywords":"FortJs Node.js web framework session session store documentation","version":"Next"},{"title":"Using session​","type":1,"pageTitle":"Session","url":"/docs/concepts/session#using-session","content":"FortJs provides a session property that is available in all components. import { Controller, http, textResult } from &quot;fortjs&quot;; export class DefaultController extends Controller { @http.get(&quot;/&quot;) async default() { // Check if session exists const isSessionExist = await this.session.isExist('userId'); // Add value to session await this.session.set('userId', 45); // Get session value const userIdFromSession = await this.session.get('userId'); // Remove session await this.session.remove('session_name'); // Set multiple sessions at a time await this.session.setMany({ 'user_id': 1, 'name': 'ujjwal gupta' }); return textResult('Welcome to FortJs'); } }  By default, FortJs stores all your session data in memory, which means data will be lost when the Node.js process is stopped or restarted. If you want to preserve your session values, you need to store your values in a database or use any tools or services. You can customize the session store by creating a session store.&quot; ","version":"Next","tagName":"h2"},{"title":"Decorators","type":0,"sectionRef":"#","url":"/docs/decorators/","content":"Decorators FortJs provides following decorators - validatorworkerroutewallshieldguard","keywords":"route worker guard shield fortjs node","version":"Next"},{"title":"validate","type":0,"sectionRef":"#","url":"/docs/decorators/validate","content":"validate Validation in Fort.js is facilitated through the validate decorator, enabling you to validate incoming data from HTTP requests. This powerful feature allows validation for: HTTP BodyQuery StringURL Parameters The validate decorator takes a DTO (Data Transfer Object) class as a parameter for validation. Read more about how to do validation using validate decorator on validation doc","keywords":"validate validation","version":"Next"},{"title":"query","type":0,"sectionRef":"#","url":"/docs/concepts/query","content":"","keywords":"query string http query get request fortjs node","version":"Next"},{"title":"Inject Query String Data​","type":1,"pageTitle":"query","url":"/docs/concepts/query#inject-query-string-data","content":"You can inject query string data into components or controller methods for easy access to HTTP request query string data. To achieve this, use the @asQuery decorator. import { Controller, http, textResult, asQuery } from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/user-info&quot;) async getUserInfo(@asQuery() queryParams) { // The 'queryParams' parameter now contains the data from the HTTP query string console.log(queryParams); // Your logic for processing user information // ... return textResult(&quot;User information retrieved successfully&quot;); } }  In this example, the @asQuery() decorator is used on the queryParams parameter of the getUserInfo method. This automatically injects the data from the HTTP query string into the queryParams parameter. You can then use this data within your method to perform the desired logic, such as processing user information in this case. Please ensure that the structure of the queryParams object aligns with the expected format and content of the data sent in the HTTP query string. ","version":"Next","tagName":"h2"},{"title":"Controller","type":0,"sectionRef":"#","url":"/docs/controller","content":"","keywords":"Fort.js Controller Web Framework Documentation Node.js Controller MVC HTTP Request Handling Web Application Logic","version":"Next"},{"title":"Controller member​","type":1,"pageTitle":"Controller","url":"/docs/controller#controller-member","content":"A controller has following members - RequestResponseCookieSessionQuery dataBody dataRoute parameterData from other components ","version":"Next","tagName":"h2"},{"title":"Creating controller​","type":1,"pageTitle":"Controller","url":"/docs/controller#creating-controller","content":"A Controller is a class that extends the Controller class from Fort.js. ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Controller","url":"/docs/controller#example","content":"import { Controller } from &quot;fortjs&quot;; export class UserController extends Controller { }  To make this controller active, you need to assign it to the routes of Fort. A controller is associated with a path. import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;./controllers&quot;; Fort.routes = [{ controller: UserController, path: &quot;/user&quot; }];  In the code, we are adding our controller to the routes array along with a path. The path is used to associate the controller with a top-level route. For example, if your website is abc.com, when a user hits the URL &quot;abc.com/user&quot;, the UserController will be executed. Note: You must have a method inside the controller with an HTTP route to allow the execution of the controller. ","version":"Next","tagName":"h3"},{"title":"Deployment Best Practice","type":0,"sectionRef":"#","url":"/docs/deployment","content":"","keywords":"deploy instructions fortjs node","version":"Next"},{"title":"Handling crash​","type":1,"pageTitle":"Deployment Best Practice","url":"/docs/deployment#handling-crash","content":"","version":"Next","tagName":"h2"},{"title":"App Crash :-​","type":1,"pageTitle":"Deployment Best Practice","url":"/docs/deployment#app-crash--","content":"Nodejs app is stopped when an exception is not handled and in this situation your website will be down until you restart the app again. For solving this - Use a process manager . Process managers can be used for other purposes too like - Configure to improve performance, Checking runtime performance &amp; resource consumption etc.  Some of the famous process managers are - PM2, Forever, StrongLoop etc. ","version":"Next","tagName":"h3"},{"title":"Server Crash :-​","type":1,"pageTitle":"Deployment Best Practice","url":"/docs/deployment#server-crash--","content":"When server crash &amp; it restarts, your app should restart too. But that don't happens until you configure it. You can hook your app to os init system or configure your process manager to os init system. We will recommend to configure your app with process manager. ","version":"Next","tagName":"h3"},{"title":"Rest","type":0,"sectionRef":"#","url":"/docs/guides/rest","content":"","keywords":"nestjs  framework  typescript  javascript  MVC","version":"Next"},{"title":"Implementation​","type":1,"pageTitle":"Rest","url":"/docs/guides/rest#implementation","content":"Our requirement is to create user REST endpoints for handling user-related operations. ","version":"Next","tagName":"h2"},{"title":"1. Data Storage​","type":1,"pageTitle":"Rest","url":"/docs/guides/rest#1-data-storage","content":"The first important part is to create a storage layer where we can access the data. For this - Let's create a user service to handle user-related operations. In the services folder, create a file named UserService.ts: services/UserService.ts export class UserService { private users: { [key: string]: any } = {}; addUser(id: string, username: string, email: string) { this.users[id] = { id, username, email }; } getUser(id: string) { return this.users[id]; } getAllUsers() { return Object.values(this.users); } }  info The primary goal of the User Service is to establish a foundation for efficient data storage and retrieval, catering specifically to user-related functionalities. By creating a service layer, you can encapsulate database-related logic, making your controllers more focused on handling HTTP requests and improving the testability of your application. This separation of concerns enhances code modularity and maintainability in the long run. ","version":"Next","tagName":"h2"},{"title":"2. Create Controller​","type":1,"pageTitle":"Rest","url":"/docs/guides/rest#2-create-controller","content":"Create a user controller to handle API endpoints related to users. In the controllers folder, create a file named UserController.ts: controllers/UserController.ts import { Controller, singleton, http jsonResult, textResult } from 'fortjs'; import { UserService } from '@/services/UserService'; export class UserController extends Controller { private userService: UserService; constructor(@singleton(UserService) userService: UserService) { super(); this.userService = userService; } @http.get(&quot;/&quot;) async getAllUser() { const users = this.userService.getAllUsers(); return jsonResult(users); } @http.post(&quot;/&quot;) async createUser() { const { id, username, email } = this.body; this.userService.addUser(id, username, email); return textResult('User added successfully'); } @http.get(&quot;/{id}&quot;) async getUser() { const { id } = this.params; const user = this.userService.getUser(id); return jsonResult(user); } }  In the above snippet - We have created three different methods mapping with respective route. Method: getAllUser HTTP Method: GETPath: &quot;/&quot;Description: Fetches all user data.Implementation: Calls getAllUsers in UserService and returns a JSON response. Method: createUser HTTP Method: POSTPath: &quot;/&quot;Description: Creates a new user.Implementation: Extracts user details, calls addUser in UserService, and returns a success message. Method: getUser HTTP Method: GETPath: &quot;/{id}&quot;Description: Retrieves user details by ID.Implementation: Extracts user ID, calls getUser in UserService, and returns a JSON response. tip We've utilized the singleton decorator to inject the userService into our controller. This approach enhances the testability of our controller. For detailed information, please refer to the Dependency Injection documentation. Similar to GET and POST API - you can create DELETE api. We will leave this to you but if needed help - feel free to ask in the github discussion. ","version":"Next","tagName":"h2"},{"title":"3. Controller route​","type":1,"pageTitle":"Rest","url":"/docs/guides/rest#3-controller-route","content":"Let's map our controller to a route. Open src/index.ts in your app and then update the routes code to - import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;@/controllers&quot;; // here we have mapped UserController with path &quot;/user&quot; Fort.routes = [ { controller: UserController, path: &quot;/user&quot; } ] await Fort.create();  tip 🚀 Explore a Complete REST API Implementation Example 🚀 Fort.js REST API Examples Feel free to dive into this comprehensive example to see how Fort.js can be used to build RESTful APIs. ","version":"Next","tagName":"h2"},{"title":"HttpRequest","type":0,"sectionRef":"#","url":"/docs/interfaces/http-request","content":"HttpRequest The type HttpRequest is used for accessing request resources like url, headers etc. interface IHttpRequest { url: string; method: HTTP_METHOD; headers: IncomingHttpHeaders; connection: net.Socket; } ","keywords":"http request type options fortjs node","version":"Next"},{"title":"HttpResponse","type":0,"sectionRef":"#","url":"/docs/interfaces/http-response","content":"HttpResponse interface IHttpResponse { setHeader(name: string, value: number | string | string[]): void; getHeader(name: string): number | string | string[] | undefined; getHeaders(): OutgoingHttpHeaders; getHeaderNames(): string[]; hasHeader(name: string): boolean; removeHeader(name: string): void; } ","keywords":"http response type options fortjs node","version":"Next"},{"title":"Database","type":0,"sectionRef":"#","url":"/docs/guides/database","content":"","keywords":"Fort.js Database Fort.js ORM Sequelize TypeORM Prisma Fort.js Database Examples Fort.js Database Connectivity MongoDB with Fort.js Fort.js CRUD Operations Database Integration in Fort.js Fort.js Data Modeling Fort.js Database Configuration Fort.js Data Persistence Fort.js Best Practices Fort.js Database Security Fort.js MySQL Fort.js SQLite Fort.js SQL Server","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Database","url":"/docs/guides/database#installation","content":"To streamline the database connection, let's install the PostgreSQL client library and Sequelize: npm i sequelize pg  For detailed installation instructions, please refer to the Sequelize installation documentation. ","version":"Next","tagName":"h2"},{"title":"Configure Sequelize​","type":1,"pageTitle":"Database","url":"/docs/guides/database#configure-sequelize","content":"Create a Sequelize configuration file, typically named sequelize.js or database.js in your project's root directory. Add the following content: // sequelize.js import { Sequelize } from 'sequelize'; export const sequelize = new Sequelize('your_database', 'your_username', 'your_password', { host: 'localhost', dialect: 'postgres', logging: false, // Set to true to log SQL queries });  Replace 'your_database', 'your_username', and 'your_password' with your PostgreSQL database name, username, and password, respectively. ","version":"Next","tagName":"h2"},{"title":"Set Up a Model​","type":1,"pageTitle":"Database","url":"/docs/guides/database#set-up-a-model","content":"Create a Sequelize model for your database table. For example, let's create a User model. In the models directory, create a file named user.js: // models/user.js import { DataTypes } from 'sequelize'; import { sequelize } from '@/sequelize'; export const User = sequelize.define('User', { username: { type: DataTypes.STRING, allowNull: false, }, email: { type: DataTypes.STRING, allowNull: false, unique: true, }, });  ","version":"Next","tagName":"h2"},{"title":"Initialize Sequelize in Fort.js​","type":1,"pageTitle":"Database","url":"/docs/guides/database#initialize-sequelize-in-fortjs","content":"async function initiateDatabase(){ // Initialize Sequelize await sequelize.authenticate(); console.log('Connection to the database has been established successfully.'); // Sync models with the database await sequelize.sync(); console.log('All models were synchronized successfully.'); }  Let's use initiateDatabase method in our application setup code. Update your index.js or app.js file: import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;./controllers&quot;; import { sequelize } from &quot;@/sequelize&quot;; async function initiateDatabase(){ // Initialize Sequelize await sequelize.authenticate(); console.log('Connection to the database has been established successfully.'); // Sync models with the database await sequelize.sync(); console.log('All models were synchronized successfully.'); } export const createApp = async () =&gt; { Fort.routes = routes; process.env.APP_URL = `http://localhost:${Fort.port}`; await initiateDatabase(); await Fort.create(); }; if (process.env.NODE_ENV !== &quot;test&quot;) { createApp().then(() =&gt; { Fort.logger.debug(`Your fort is located at address - ${process.env.APP_URL}`); }).catch(err =&gt; { console.error(err); }); }  ","version":"Next","tagName":"h2"},{"title":"Use Sequelize Models​","type":1,"pageTitle":"Database","url":"/docs/guides/database#use-sequelize-models","content":"Now you can use the Sequelize models in your Fort.js controllers or services. For example: controllers/userController.js import { Controller, jsonResult, http } from 'fortjs'; import { User } from '@/models/user'; export class UserController extends Controller { @http.get(&quot;/&quot;) async getAllUsers() { const users = await User.findAll(); return jsonResult(users); } }  ","version":"Next","tagName":"h2"},{"title":"Create Service File​","type":1,"pageTitle":"Database","url":"/docs/guides/database#create-service-file","content":"While using models directly can work, it tightly couples our controller to the database, making unit testing of the controller challenging. That's why it's recommended to establish a service layer. tip By creating a service layer, you can encapsulate database-related logic, making your controllers more focused on handling HTTP requests and improving the testability of your application. This separation of concerns enhances code modularity and maintainability in the long run. Let's create a file user_service.js inside the folder services services/user_service.js import { User } from '@/models/user'; export class UserService { async findAll(){ const users = await User.findAll(); return users; } }  ","version":"Next","tagName":"h2"},{"title":"Use Service File in the Controller​","type":1,"pageTitle":"Database","url":"/docs/guides/database#use-service-file-in-the-controller","content":"While we can directly import the service file and use it, it is recommended to inject it as a dependency using the singleton decorator. This approach ensures that our controllers are loosely coupled, making them more testable. By injecting the service as a dependency, we adhere to the principles of dependency injection, promoting a cleaner and more modular design. This makes it easier to substitute dependencies during testing and allows for better code maintainability. import { Controller, jsonResult, singleton, http } from 'fortjs'; import { UserService } from '@/services/user_service'; export class UserController extends Controller { constructor(@singleton(UserService) userService){ super(); this.userService = userService; } @http.get(&quot;/&quot;) async getAllUsers() { const users = await this.userService.findAll(); return jsonResult(users); } }  Similar to the above snippet, you can use any other database and ORM library. Here are links to some examples: PgSQL examplesMongoDB examples ","version":"Next","tagName":"h3"},{"title":"ViewEngineData","type":0,"sectionRef":"#","url":"/docs/interfaces/view-engine-data","content":"ViewEngineData The interface IViewEngineData is used by ViewEngine to get view related data from workers. interface IViewEngineData { /** * name of the view or path of view * * @type {string} */ view: string; /** * view model * * @type {*} */ model: any; } ","keywords":"view engine data types fortjs node","version":"Next"},{"title":"Get started","type":0,"sectionRef":"#","url":"/docs/get-started","content":"","keywords":"Fort.js web framework Node.js getting started setup basics web development JavaScript TypeScript server-side MVC architecture RESTful APIs modular code controllers routes components dependency injection shields guards documentation","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"Get started","url":"/docs/get-started#setup","content":"Fort.js provides fort-creator to streamline project setup and development. ","version":"Next","tagName":"h2"},{"title":"Initiate a New Project​","type":1,"pageTitle":"Get started","url":"/docs/get-started#initiate-a-new-project","content":"npx fort-creator init  Follow the prompts to choose your project language (typescript or javascript). Fort-creator will generate the project for you. ","version":"Next","tagName":"h3"},{"title":"Run the Project​","type":1,"pageTitle":"Get started","url":"/docs/get-started#run-the-project","content":"cd &lt;project-name&gt; npm run dev  Open your browser and navigate to http://localhost:4000 to view the Fort.js default page. ","version":"Next","tagName":"h3"},{"title":"Basics​","type":1,"pageTitle":"Get started","url":"/docs/get-started#basics","content":"Let's delve into some fundamentals of fortjs - ControllerHttp RouteBootstrapping ","version":"Next","tagName":"h2"},{"title":"Controller​","type":1,"pageTitle":"Get started","url":"/docs/get-started#controller","content":"A Controller in Fortjs is a class responsible for defining methods that handle specific HTTP endpoints. It encapsulates the logic for processing incoming requests and generating appropriate responses. Controllers play a pivotal role in organizing and structuring the application's request-handling logic. 👉 Each controller represents an endpoint, which is mapped to a path known as the controller route. In our current code, the DefaultController is mapped to the route /*. src/controllers/default_controller import { Controller, viewResult, assign, http } from &quot;fortjs&quot;; export class DefaultController extends Controller { @http.get(&quot;/&quot;) async index(@assign('FortJs') title) { const data = { title: title } const result = await viewResult('../src/views/default/index.html', data); return result; } }  src/routes import { DefaultController } from &quot;@/controllers/default_controller&quot;; export const routes = [{ path: &quot;/*&quot;, controller: DefaultController }]  Here, you can observe that the DefaultController has been mapped with the path &quot;/*&quot;, which signifies a controller-level route. For more detailed information on controllers, please refer to the Controller documentation. ","version":"Next","tagName":"h3"},{"title":"Http Route​","type":1,"pageTitle":"Get started","url":"/docs/get-started#http-route","content":"Http Routes are endpoints associated with controller methods. When the endpoint is called, the method linked to that specific endpoint is executed. A special decorator called http is utilized to define the supported Http Method for your endpoint, along with specifying the path. Here's an example from the created project: src/controllers/default_controller import { Controller, viewResult, assign, http } from &quot;fortjs&quot;; export class DefaultController extends Controller { @http.get(&quot;/&quot;) async index(@assign('FortJs') title) { const data = { title: title } const result = await viewResult('../src/views/default/index.html', data); return result; } }  In the provided code, the @http.get decorator is used to specify that our endpoint supports only the GET Http Method, and the parameter value &quot;/&quot; is passed to set the endpoint path. So, when we access http://localhost:4000/, the index method is executed, and we see an HTML page in the response. Let's create another method helloWorld which will be mapped with endpoint hello-world and it will return text Hello World. src/controllers/default_controller import { Controller, viewResult, assign, http } from &quot;fortjs&quot;; export class DefaultController extends Controller { @http.get(&quot;/&quot;) async index(@assign('FortJs') title) { const data = { title: title } const result = await viewResult('../src/views/default/index.html', data); return result; } @http.get(&quot;/hello-world&quot;) async helloWorld(){ return textResult(&quot;Hello World&quot;); } }  Now, navigate to the URL http://localhost:4000/hello-world. For additional details on routes, please refer to the routes documentation. ","version":"Next","tagName":"h3"},{"title":"Bootstrapping​","type":1,"pageTitle":"Get started","url":"/docs/get-started#bootstrapping","content":"Bootstrapping in Fort.js is straightforward. The minimum requirement involves defining your controller routes and providing them to Fort.js. src/index import * as path from &quot;path&quot;; import { Fort } from &quot;fortjs&quot;; import { routes } from &quot;@/routes&quot;; export const createApp = async () =&gt; { Fort.routes = routes; process.env.APP_URL = `http://localhost:${Fort.port}`; await Fort.create(); }; if (process.env.NODE_ENV !== &quot;test&quot;) { createApp().then(() =&gt; { Fort.logger.debug(`Your fort is located at address - ${process.env.APP_URL}`); }).catch(err =&gt; { console.error(err); }); }  Read the Bootstrapping documentation for more detailed information.  We hope this provides you with a basic understanding of Fortjs. If you have any doubts or specific requirements, please feel free to create a discussion or issue on GitHub.  ","version":"Next","tagName":"h3"},{"title":"Resources​","type":1,"pageTitle":"Get started","url":"/docs/get-started#resources","content":"Guides Fortjs examples Rest Api Example MongoDb Example Crud operation using html form ","version":"Next","tagName":"h2"},{"title":"IHttpResult","type":0,"sectionRef":"#","url":"/docs/interfaces/http-result","content":"","keywords":"http result type options fortjs node","version":"Next"},{"title":"Returning data​","type":1,"pageTitle":"IHttpResult","url":"/docs/interfaces/http-result#returning-data","content":"Let's see an example to return a text data - import { Controller, http, HTTP_STATUS_CODE, MIME_TYPE } from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/&quot;) async default () { return { statusCode: HTTP_STATUS_CODE.Ok, responseData: &quot;Hello World&quot;, contentType: MIME_TYPE.Text }; } }  In the above snippet - we are sending data &quot;Hello World&quot; with MIME Type Text which tells browser to consider this as text result. ","version":"Next","tagName":"h2"},{"title":"Helper methods​","type":1,"pageTitle":"IHttpResult","url":"/docs/interfaces/http-result#helper-methods","content":"FortJs provides some helper method which return result of type IHttpResult. These are - textResult - used to return text result.jsonResult - used to return json result.htmlResult - used to return html result.viewResult - used to return a view.fileResult - used to return a file which will be rendered by browser.downloadResult - used to return a file which will be downloaded by browser.redirectResult - used to return a result which will tell browser to redirect url. ","version":"Next","tagName":"h2"},{"title":"Returning text data using helper method​","type":1,"pageTitle":"IHttpResult","url":"/docs/interfaces/http-result#returning-text-data-using-helper-method","content":"import { Controller, http, textResult } from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/&quot;) async default () { return textResult(&quot;Hello World&quot;); } }  You can see - helper methods make things very easy and clean. ","version":"Next","tagName":"h2"},{"title":"Http Result","type":0,"sectionRef":"#","url":"/docs/http-result","content":"","keywords":"FortJs HTTP Results Text Result JSON Result HTML Result View Result File Result Download Result Redirect Result Web Development Node.js","version":"Next"},{"title":"Text data​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#text-data","content":"import { Controller, http, textResult } from &quot;fortjs&quot;; export class MyController extends Controller { @http.get(&quot;/hello-world&quot;) async default() { // This method returns a simple text result with the content &quot;Hello World&quot;. return textResult(&quot;Hello World&quot;); } }  ","version":"Next","tagName":"h2"},{"title":"JSON data​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#json-data","content":"import { Controller, http, jsonResult } from &quot;fortjs&quot;; export class MyController extends Controller { @http.get(&quot;/hello-world&quot;) async default() { // This method returns a simple json data with the content &quot;Hello World&quot;. return jsonResult({ value: &quot;Hello World&quot; }); } }  ","version":"Next","tagName":"h2"},{"title":"HTML data​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#html-data","content":"import { Controller, http, htmlResult } from &quot;fortjs&quot;; export class MyController extends Controller { @http.get(&quot;/hello-world&quot;) async default() { // This method returns a simple html data with the content &quot;Hello World&quot;. return htmlResult(`&lt;h1&gt;Hello World&lt;/h1&gt;`); } }  ","version":"Next","tagName":"h2"},{"title":"Redirect url​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#redirect-url","content":"import { Controller, http, redirectResult } from &quot;fortjs&quot;; export class MyController extends Controller { @http.get(&quot;/hello-world&quot;) async default() { // This method returns url which tells browser to redirect to supplied url return redirectResult(`https://fortjs.net/`); } }  ","version":"Next","tagName":"h2"},{"title":"Render file​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#render-file","content":"import { Controller, http, fileResult } from &quot;fortjs&quot;; import * as path from &quot;path&quot; export class MyController extends Controller { @http.get(&quot;/image&quot;) async default() { // This method returns a file which tells browser to render the file like show an image const pathLocation = path.join(__dirname, &quot;../contents/JsStore_16_16.png&quot;); return fileResult(pathLocation); } }  ","version":"Next","tagName":"h2"},{"title":"Download file​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#download-file","content":"import { Controller, http, downloadResult } from &quot;fortjs&quot;; import * as path from &quot;path&quot; export class MyController extends Controller { @http.get(&quot;/download&quot;) async default() { // This method returns a file which tells browser to download the file const pathLocation = path.join(__dirname, &quot;../contents/JsStore_16_16.png&quot;); return downloadResult(pathLocation); } }  ","version":"Next","tagName":"h2"},{"title":"Render a view file​","type":1,"pageTitle":"Http Result","url":"/docs/http-result#render-a-view-file","content":"import { Controller, http, viewResult } from &quot;fortjs&quot;; export class MyController extends Controller { @http.get(&quot;/view&quot;) async default() { // This method renders a view file and then returns the HTML data. // It uses the viewResult helper from FortJs. const data = { title: &quot;Hello world&quot; }; return viewResult(&quot;views/default/index.html&quot;, data); } }  For more information on views, please refer to the View Engine Documentation. ","version":"Next","tagName":"h2"},{"title":"Setup","type":0,"sectionRef":"#","url":"/docs/setup","content":"","keywords":"bootstrap setup initiate start fortjs node","version":"Next"},{"title":"Configuring App​","type":1,"pageTitle":"Setup","url":"/docs/setup#configuring-app","content":"FortJs provides different configurations like - port, folders, appName etc. import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;./controllers&quot;; Fort.appName = &quot;MyAwesomeApp&quot;; Fort.port = 8080 Fort.routes = [{ controller: UserController, path: &quot;/user&quot; }] Fort.create();  ","version":"Next","tagName":"h2"},{"title":"Configuration options​","type":1,"pageTitle":"Setup","url":"/docs/setup#configuration-options","content":"appName - name of application - default is fort. Visible in header and cookie. Change name if you dont want any one to know the framework name.port - Port at which app will listen, default - 4000logger - Supply your custom logger.viewPath - Views folder location. By default it is - views.folders - folders which should be visible to requests. By default nothing is allowed.eTag - eTag Settingswalls - List of wallscustomErrorHandler - A custom error handler class which will be used when framework detects error.shouldParseBody - Whether to parse http body data in post request or not. It is boolean value and default value is true.shouldParseCookie - Whether to parse cookie or not. It is boolean value and default value is true. ","version":"Next","tagName":"h3"},{"title":"Swagger","type":0,"sectionRef":"#","url":"/docs/swagger/","content":"Swagger Swagger is an open-source software framework backed by a large ecosystem of tools that helps developers design, build, document, and consume RESTful Web services. FortJs provides a seperate library - fortjs-swagger for swagger integration. It provides automatic generation of swagger documents. Read the following docs for more information - Initiate Swagger Defining model in swagger","keywords":"swagger automatic generate integrate fortjs node","version":"Next"},{"title":"Test","type":0,"sectionRef":"#","url":"/docs/test/","content":"","keywords":"test unit e2e fortjs node","version":"Next"},{"title":"Test Command​","type":1,"pageTitle":"Test","url":"/docs/test/#test-command","content":"The default setup is configured with script test, so command - npm run test will run all test cases. It sets the NODE_ENV as test. Test Examples​ Unit Test e2e Test ","version":"Next","tagName":"h2"},{"title":"Route","type":0,"sectionRef":"#","url":"/docs/route","content":"","keywords":"Rest api route route configuration route handling url mapping Routing in fortjs","version":"Next"},{"title":"Rest API​","type":1,"pageTitle":"Route","url":"/docs/route#rest-api","content":"Let's understand routing configuration by creating a Rest API : A User rest api ","version":"Next","tagName":"h2"},{"title":"Create controller​","type":1,"pageTitle":"Route","url":"/docs/route#create-controller","content":"The first step is to create a controller and associate it with a controller route. Let's name it - UserController import { Controller,} from &quot;fortjs&quot;; export class UserController extends Controller { }  The second step is to associate with it a path and add this to Fort.routes array - import { Fort } from &quot;fortjs&quot;; import { UserController } from &quot;@/controllers&quot;; // here we have mapped UserController with path &quot;/user&quot; Fort.routes = [{ controller: UserController, path: &quot;/user&quot; }] await Fort.create();  Here we have used path &quot;/user&quot;, which means - UserController will be executed when path &quot;/user&quot; will be called. ","version":"Next","tagName":"h3"},{"title":"Create Http Route​","type":1,"pageTitle":"Route","url":"/docs/route#create-http-route","content":"HTTP routes in Fortjs serve as endpoints that are tightly linked with controller methods. When a specific endpoint is invoked, the corresponding method in the associated controller is executed. A special decorator http is used to - define which Http Method` you want to support for your end point. path of your endpoint now let's create some endpoints for our rest API. Get​ Let's define our first route to fetch all users. Our objective is to trigger the associated controller method when the URL is 'http://localhost:4000/user/all'. import { Controller, http, jsonResult} from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/all&quot;) fetchAllUsers(){ const allUsers = []; return jsonResult(allUsers); } }  In the code snippet, we've created a UserController with a method called fetchAllUsers. This method is linked to the path &quot;/all&quot; and HTTP method GET using the decorator @http.get(&quot;/all&quot;). Therefore, it will be triggered when the URL is 'http://localhost:4000/user/all' info Wondering about the presence of '/user' in the route 'http://localhost:4000/user/all'? It's the controller route we configured in the controller section. This setup offers a neat structure for organizing related routes under the common path '/user'. Note: We won't delve into the details of the logic for fetching the user, as covering the logical part is beyond the scope of this documentation.  Now let's create an endpoint that will return the user by ID. Our objective is to trigger the method when the URL is 'http://localhost:4000/user/1', where 1 is the user's ID. This ID can vary, for example, the user ID can be 2, 3, 4, etc. import { Controller, http, jsonResult} from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/all&quot;) fetchAllUsers(){ const allUsers = []; return jsonResult(allUsers); } @http.get(&quot;/{userId}&quot;) fetchUserById(){ const userId = this.param.userId; const user = {}; return jsonResult(user); } }  In the above snippet, we have created a method fetchUserById. This method is linked to the path &quot;/{userId}&quot; and HTTP method GET using the decorator @http.get(&quot;/{userId}&quot;). Therefore, it will be triggered when the URL is 'http://localhost:4000/user/1' or 'http://localhost:4000/user/2'. This covers our GET route customization. Now let's learn about POST route. POST​ info The POST HTTP method is used to submit or send data to the specified resource. When a client makes a POST request, the data is included in the body of the request. Let's create an endpoint for creating a user. Our objective is to execute the 'createUser' method when the URL is 'http://localhost:4000/user' and the HTTP method is POST import { Controller, http, jsonResult} from &quot;fortjs&quot;; export class UserController extends Controller { @http.get(&quot;/all&quot;) fetchAllUsers(){ const allUsers = []; return jsonResult(allUsers); } @http.get(&quot;/{userId}&quot;) fetchUserById(){ const userId = this.param.userId; const user = {}; return jsonResult(user); } @http.post(&quot;/&quot;) createUser(){ const newUserData = this.body; return jsonResult(newUserData); } }  In the above snippet, we have created a method createUser. This method is linked to the path &quot;/&quot; and HTTP method POST using the decorator @http.post(&quot;/&quot;). Therefore, it will be triggered when the URL is 'http://localhost:4000/user' and HTTP method is POST  In addition to the examples mentioned earlier, you can utilize other HTTP methods as follows: Patch: @http.patchPut: @http.putDelete: @http.delete Feel free to incorporate these methods into your routes as needed. tip 🚀 Explore a Complete REST API Implementation Example 🚀 Fort.js REST API Examples Feel free to dive into this comprehensive example to see how Fort.js can be used to build RESTful APIs. ","version":"Next","tagName":"h3"},{"title":"Initialize Controller","type":0,"sectionRef":"#","url":"/docs/test/initialize","content":"Initialize Controller initialize is a method in a controller which initializes a controller &amp; set the controller property provided in param. This is helpful when you are doing unit testing where you want to set the controller properties. e.g - Let's say i want to set the body &amp; query of UserController const userControllerObj = new UserController(); userControllerObj.initialize({ body:{ name:'ujjwal', gender:'male' }, query:{ id:1 } }) In same way - you can set other properties - request: HttpRequest;query: { [key: string]: string };body: { [key: string]: any };cookieValue: { [key: string]: string };param: { [key: string]: string };data: { [key: string]: any };file: { [fieldName: string]: HttpFile }","keywords":"test unit initialize fortjs node","version":"Next"},{"title":"Swagger Model","type":0,"sectionRef":"#","url":"/docs/swagger/model","content":"","keywords":"swagger automatic generate integrate fortjs node","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Swagger Model","url":"/docs/swagger/model#configuration","content":"A Model can have different configuration like a field can be optional and other field can be required etc. Fortjs provides different decorators to configure the model - Optional PropertyIgnore PropertyExample Let's see what are the uses of these configuration &amp; how to use - Consider a model &quot;User&quot; which has following structure - class User { id: string; name : String; address: string; gender: string; isValidUser : Function; }  ","version":"Next","tagName":"h2"},{"title":"OptionalProperty​","type":1,"pageTitle":"Swagger Model","url":"/docs/swagger/model#optionalproperty","content":"Consider the property id in the model &quot;User&quot; represents a primary key which means its automatically generated, In that case - id is not required in a &quot;POST&quot; request - since new record will be created and new id will be generated for that request. But it can be a required field in &quot;PUT&quot; request to identify the record. So from above statement we found that id is sometimes required and sometimes not. For this condition - we can use decorator OptionalProperty which will mark the field as optional in swagger doc. import { OptionalProperty } from &quot;fortjs-swagger&quot;; class User { @OptionalProperty id: string; name : String; address: string; gender: string; isValidUser : Function; }  ","version":"Next","tagName":"h3"},{"title":"IgnoreProperty​","type":1,"pageTitle":"Swagger Model","url":"/docs/swagger/model#ignoreproperty","content":"IgnoreProperty can be used to ignore a property in the model. Let's focus on property isValidUser, its a method which is being used internally in the application but it doesn't need to be specified in the swagger doc. import { IgnoreProperty, OptionalProperty } from &quot;fortjs-swagger&quot;; class User { @OptionalProperty id: string; name : String; address: string; gender: string; @IgnoreProperty isValidUser : Function; }  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Swagger Model","url":"/docs/swagger/model#example","content":"Fortjs-Swagger calls getExample to generate the example for your model. e.g - Let's see how we can provide an example for our model &quot;User&quot; import { IgnoreProperty, OptionalProperty, SwaggerModel } from &quot;fortjs-swagger&quot;; class User implements SwaggerModel { @OptionalProperty id: string; name : String; address: string; gender: string; @IgnoreProperty isValidUser : Function; // initialize the fields which we want to show in example getExample(){ this.id = 0; this.name = &quot;ujjwal&quot;; this.address = &quot;Planet earth&quot;; this.gender = &quot;male&quot;; } }  ","version":"Next","tagName":"h3"},{"title":"E2E Test","type":0,"sectionRef":"#","url":"/docs/test/e2e-test","content":"","keywords":"test unit e2e fortjs node","version":"Next"},{"title":"Test code​","type":1,"pageTitle":"E2E Test","url":"/docs/test/e2e-test#test-code","content":"import axios from &quot;axios&quot;; import { createApp } from &quot;../index&quot;; describe('/user', () =&gt; { let httpRequest; beforeAll(async () =&gt; { await createApp(); httpRequest = axios.create({ baseURL: process.env.APP_URL + &quot;/user&quot;, timeout: 1000 }); }); it('/get all users', async () =&gt; { const response = await httpRequest.get('/', { headers: { accept: 'application/json' } }); expect(response.status).toEqual(200); expect(response.headers['content-type']).toEqual('application/json'); expect(response.data).toEqual([ { &quot;address&quot;: &quot;bhubaneswar india&quot;, &quot;emailId&quot;: &quot;ujjwal@mg.com&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;id&quot;: 1, &quot;name&quot;: &quot;ujjwal&quot;, &quot;password&quot;: &quot;admin&quot; } ]); }); it('/add user', async () =&gt; { const user = { &quot;name&quot;: &quot;ujjwal&quot;, &quot;emailId&quot;: &quot;ujjwal@m.com&quot;, &quot;password&quot;: &quot;12345as&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;address&quot;: &quot;sadfsgbhfgtbrg&quot; }; const response = await httpRequest.post('/', user, { headers: { accept: 'application/json' } }); expect(response.status).toEqual(201); expect(response.headers['content-type']).toEqual('application/json'); expect(response.data).toEqual({ id: 2, ...user }); }); it('/update user', async () =&gt; { const user = { &quot;name&quot;: &quot;ujjwal gupta&quot;, &quot;emailId&quot;: &quot;ujjwal@m.com&quot;, &quot;password&quot;: &quot;12345as&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;address&quot;: &quot;sadfsgbhfgtbrg&quot;, &quot;id&quot;: 2 }; const response = await httpRequest.put('/', user, { headers: { accept: '*/*' } }); expect(response.status).toEqual(200); expect(response.data).toEqual(&quot;user updated&quot;); }); });  In the above code - We are initializing our app and creating an axios instance in beforeAll hook of jest. This will ensure that our app is initialized before any test case is executed. In test case &quot;get all users&quot; - we create a get request to user end point and then send the request, after response is received we compare it against expected output. ","version":"Next","tagName":"h2"},{"title":"Initiate Swagger","type":0,"sectionRef":"#","url":"/docs/swagger/initiate","content":"","keywords":"swagger automatic generate integrate fortjs node","version":"Next"},{"title":"1. Install library​","type":1,"pageTitle":"Initiate Swagger","url":"/docs/swagger/initiate#1-install-library","content":"npm install fortjs-swagger  ","version":"Next","tagName":"h2"},{"title":"2. Initiate​","type":1,"pageTitle":"Initiate Swagger","url":"/docs/swagger/initiate#2-initiate","content":"initiate the swagger after the fortjs has started. import * as Path from &quot;path&quot;; import { Fort } from &quot;fortjs&quot;; import { Swagger } from &quot;fortjs-swagger&quot;; import { routes } from &quot;./routes&quot;; Fort.routes = routes; // allow swagger path to access using url with alias swagger Fort.folders = [{ alias: &quot;swagger&quot;, path: Path.join(__dirname, &quot;../swagger/&quot;) }]; Fort.create().then(() =&gt; { // initiating swagger Swagger.create({ appInfo: { title: &quot;Swagger Test&quot;, description: &quot;Swagger Test&quot;, version: &quot;1.0&quot; }, servers: [{ description: &quot;local&quot;, url: &quot;http://localhost:4000&quot; }], // create swagger files at this path outputPath: swaggerPath, securitySchemes: { basicAuth: { type: &quot;http&quot;, scheme: &quot;basic&quot; } } }); })  Will it generate docs now ? No, This is only setup to initiate swagger. We need to tell fortjs what we are expecting exactly i.e - what will be the structure of http request &amp; structure of http response etc. Consider the below controller import { Controller, textResult, defaultWorker, jsonResult, worker, route, HTTP_STATUS_CODE, HTTP_METHOD, Guards, Shields } from 'fortjs'; import { UserService } from '../services/user_service'; import { User } from '../models/user'; import { Response, Body, Param, Summary, Description, Security } from 'fortjs-swagger'; export class UserController extends Controller { @defaultWorker() async getUsers() { const service = new UserService(); return jsonResult(service.getUsers()); } @worker([HTTP_METHOD.Post]) @route(&quot;/&quot;) async addUser() { const user = this.data.user; const service = new UserService(); const newUser = service.addUser(user); return jsonResult(newUser, HTTP_STATUS_CODE.Created); } @worker([HTTP_METHOD.Put]) @route(&quot;/&quot;) async updateUser() { const user: User = this.data.user; const userUpdated = new UserService().updateUser(user); if (userUpdated === true) { return textResult(&quot;user updated&quot;); } else { return textResult(&quot;invalid user&quot;); } } @worker([HTTP_METHOD.Get]) @route(&quot;/{id}&quot;) async getUser() { const userId = Number(this.param.id); const user = new UserService().getUser(userId); if (user == null) { return textResult(&quot;invalid id&quot;); } return jsonResult(user); } @worker([HTTP_METHOD.Delete]) @route(&quot;/{id}&quot;) async removeUser() { const userId = Number(this.param.id); const service = new UserService(); const user = service.getUser(userId); if (user != null) { service.removeUser(userId); return textResult(&quot;user deleted&quot;); } else { return textResult(&quot;invalid user&quot;); } } }  The above controller does operation for a user. And every end point exepects different request and return different response. We need to tell these info to swagger. Let's document the worker - &quot;getUsers&quot;. import { Response, Summary, Description} from 'fortjs-swagger'; @Summary('get all users') @Description('return all saved users') @Response(HTTP_STATUS_CODE.Ok, [User]) @defaultWorker() async getUsers() { const service = new UserService(); return jsonResult(service.getUsers()); }  Here we have used three different decorators - Summary - used to define the summary of the end pointDescription - used to describe the end point in details. This is not necessary most of the time.Response - used to define the response returned. In this example - we are telling swagger that : for http status &quot;OK&quot; the result will be array of model User. You can define multiple response in the same way i.e by using response decorator multiple time. In the similar way - we can define other workers. ","version":"Next","tagName":"h2"},{"title":"More resources​","type":1,"pageTitle":"Initiate Swagger","url":"/docs/swagger/initiate#more-resources","content":"Examples - https://github.com/ujjwalguptaofficial/fortjs-swagger/tree/master/examples ","version":"Next","tagName":"h2"},{"title":"Validation","type":0,"sectionRef":"#","url":"/docs/validation","content":"","keywords":"validation HTTP Body validation QueryString validation URL Parameter validation Data validation","version":"Next"},{"title":"Validate HTTP Body​","type":1,"pageTitle":"Validation","url":"/docs/validation#validate-http-body","content":"HTTP Body validation is achieved using the @validate.body decorator. Simply pass the DTO class as a parameter to enforce validation. import { Controller, jsonResult, HTTP_STATUS_CODE, http, validate } from 'fortjs'; import { User } from '@/models/user'; export class UserController extends Controller { @http.post(&quot;/&quot;) @validate.body(User) async addUser() { const newUser = this.body; return jsonResult(newUser, HTTP_STATUS_CODE.Created); } }  Here is an example of how our DTO class looks like - import { Length, Contains, IsIn, IsEmail, IsNumber } from &quot;class-validator&quot;; export class User { @IsNumber() id?: number; @Length(5) name: string; @IsEmail() emailId: string; constructor(user: any) { this.id = Number(user.id); this.name = user.name; this.emailId = user.emailId; } }  tip The validator passes the request data into the constructor of the DTO class, providing an opportunity to customize it based on specific requirements. For instance: Changing data typesRemoving extra data ","version":"Next","tagName":"h2"},{"title":"Validate Query string​","type":1,"pageTitle":"Validation","url":"/docs/validation#validate-query-string","content":"Url Query string validation is achieved using the @validate.query decorator. Simply pass the DTO class as a parameter to enforce validation. import { Controller, textResult, HTTP_STATUS_CODE, http, validate } from 'fortjs'; import { User } from '@/models/user'; import { IsNumber } from &quot;class-validator&quot;; class RemoveQueryStringDTO{ @IsNumber() id:number; constructor(data){ // the id from query string will be always string, so it needs to be converted into number this.id = Number(data.id); } } export class UserController extends Controller { @http.delete(&quot;/&quot;) @validate.query(RemoveQueryStringDTO) async removeByQueryString() { // taking id from query string const userId = this.query.id; return textResult(&quot;invalid user&quot;, 404); } }  ","version":"Next","tagName":"h2"},{"title":"Validate Url Param​","type":1,"pageTitle":"Validation","url":"/docs/validation#validate-url-param","content":"Url Param validation is achieved using the @validate.param decorator. Simply pass the DTO class as a parameter to enforce validation. import { Controller, textResult, HTTP_STATUS_CODE, http, validate } from 'fortjs'; import { User } from '@/models/user'; export class UserController extends Controller { @http.delete(&quot;/{id}&quot;) @validate.param(RemoveQueryStringDTO) async removeUser() { // taking id from param const userId = this.param.id; return textResult(&quot;invalid user&quot;, 404); } }  tip The validate decorator internally utilizes powerful components called Guard and Shield. These components are versatile and offer a high level of reusability, making them excellent choices for validation purposes. If you need to add any custom validation, you can leverage these components. Note:- The default validator uses class-validator for validation but you can customize it also. Please read validator doc. ","version":"Next","tagName":"h2"},{"title":"Unit test","type":0,"sectionRef":"#","url":"/docs/test/unit-test","content":"","keywords":"test unit e2e fortjs node","version":"Next"},{"title":"Test code -​","type":1,"pageTitle":"Unit test","url":"/docs/test/unit-test#test-code--","content":"describe('UserController', () =&gt; { let controller; beforeAll(async () =&gt; { await createApp(); // UserController has dependency of UserService, which is injected by fortjs at run time. // Here UserService is a fake service in memory controller = new UserController(new UserService()); }); it('getUsers', async () =&gt; { controller.initialize(); const expectedResult = jsonResult(controller.service.getUsers()); const result = await controller.getUsers(); expect(result).toEqual(expectedResult); }); it('addUser', async () =&gt; { const newUser = { name: 'ujjwal gupta', emailId: 'ujjwal@m.com', gender: 'male', password: 'asdfvg', address: 'Bangalore India' }; controller.initialize({ data: { user: newUser } }); const expectedResult = jsonResult(newUser, 201); const result = await controller.addUser(); expect(result).toEqual(expectedResult); expect(result.responseData).toEqual(newUser); }); it('getUser', async () =&gt; { controller.initialize({ param: { id: '2' } }); const expectedResult = jsonResult(controller.service.getUser(2)); const result = await controller.getUsers(); expect(result).toEqual(expectedResult); }); it('updateUser', async () =&gt; { const userData = { id: 2, name: 'ujjwal gupta', emailId: 'ujjwal@m.com', gender: 'male', password: 'asdfvg', address: 'Bangalore India' }; // update user for existing data controller.initialize({ body: { user: userData } }); let expectedResult = await textResult(&quot;user updated&quot;); let result = await controller.updateUser(); expect(result).toEqual(expectedResult); // update user for not existing data userData.id = 5; controller.initialize({ data: { user: userData } }); expectedResult = textResult(&quot;invalid user&quot;); result = await controller.updateUser(); expect(result).toEqual(expectedResult); }); afterAll(() =&gt; { return Fort.destroy(); }); });  In the above code - beforeAll - We are configuring everything that we need bofore test starts in &quot;beforeAll&quot; hook of jest i.e - creating the UserController object and starting our app. The hook can be different in another framework. getUsers - Here we have written code for testing getUsers. &quot;getUsers&quot; is a method which returns all the user presents. As you can see, the first line of the code is 'controller.initialize' - this is very important to call before any test case start. The 'initialize' method is present in every component i.e - controller, guard, wall &amp; shield. This is used to initialize the controller with some value i.e setting body object, setting query string etc, basically to set the component props. addUser - &quot;addUser&quot; method takes user data from body &amp; add a user. We are using 'controller.initialize' to supply the user information in body. But in code, we are actually supplying user information in data but not body - this is because method &quot;addUser&quot; uses a Guard ModelUserGuard which sends user info in data &amp; the worker &quot;addUser&quot; uses data property of controller. updateUser - &quot;updateUser&quot; method takes user data from body &amp; update user if exist otherwise returns 'invalid user'. The test code initialise the controller using 'controller.initialize' &amp; supply the user information in body. Here we are not using any guard (for explainining how to pass body i have removed guard from this method). Hope this is clear &amp; understandable. For help - please reach to our gitter channel. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}